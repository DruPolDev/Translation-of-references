<html xmlns:msxsl="urn:schemas-microsoft-com:xslt" xmlns:mssdk="winsdk" xmlns:script="urn:script" xmlns:build="urn:build" xmlns:MSHelp="http://msdn.microsoft.com/mshelp">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
<meta name="Description" content="The BAD_POOL_CALLER bug check has a value of 0x000000C2. This indicates that the current thread is making a bad pool request."/>
<meta name="MSHAttr" content="PreferredSiteName:MSDN"/>
<meta name="MSHAttr" content="PreferredLib:/library/windows/hardware"/>
<title>(Developer Content) Bug Check 0xC2: BAD_POOL_CALLER</title>

<meta name="MS-HAID" content="t06_bugs_B0_7a93f797-6ab2-41ff-bbae-20e9e66897d5.xml"/>


<link rel="STYLESHEET" type="text/css" HREF="../common/backsdk4.css"/>


</head>
<body>

<div id="mainSection">
<div class="clsServerSDKContent">
<h1><a id="debugger.bug_check_0xc2__bad_pool_caller"></a>(Developer Content) Bug Check 0xC2: BAD_POOL_CALLER</h1>
</div>
<p>The BAD_POOL_CALLER bug check has a value of 0x000000C2. This indicates that the current thread is making a bad pool request. </p>
<p>
<div class="alert"><b>Important </b>This topic is for programmers. If you are a customer who has received a blue screen error code while using your computer, see 
            <a href="http://windows.microsoft.com/en-us/windows-10/troubleshoot-blue-screen-errors" xmlns:loc="http://microsoft.com/wdcml/l10n">Troubleshoot blue screen errors</a>.</div>
</p>
<h2> BAD_POOL_CALLER Parameters</h2>
<p>The following parameters are displayed on the blue screen. <b>Parameter 1</b> indicates the type of violation.</p>
<table>
<tr>
<th>Parameter 1</th>
<th>Parameter 2</th>
<th>Parameter 3</th>
<th>Parameter 4</th>
<th>Cause of Error</th>
</tr>
<tr>
<td>
<p>0x00</p>
</td>
<td>
<p>0 </p>
</td>
<td>
<p>Pool type</p>
</td>
<td>
<p>Pool tag</p>
</td>
<td>
<p>The current thread requested a zero-byte pool allocation.</p>
</td>
</tr>
<tr>
<td>
<p>0x01,</p>
<p>0x02,</p>
<p>0x04</p>
</td>
<td>
<p>Pointer to pool header</p>
</td>
<td>
<p>First part of pool header contents</p>
</td>
<td>
<p>0 </p>
</td>
<td>
<p>The pool header has been corrupted.</p>
</td>
</tr>
<tr>
<td>
<p>0x06</p>
</td>
<td>
<p>Reserved  </p>
</td>
<td>
<p>Pointer to pool header</p>
</td>
<td>
<p>Pool header contents</p>
</td>
<td>
<p>The current thread attempted to free the pool, which was already freed.</p>
</td>
</tr>
<tr>
<td>
<p>0x07</p>
</td>
<td>
<p>Reserved  </p>
</td>
<td>
<p>Pool header contents </p>
</td>
<td>
<p>Address of the block of pool being freed </p>
</td>
<td>
<p>The current thread attempted to free the pool, which was already freed.</p>
</td>
</tr>
<tr>
<td>
<p>0x08</p>
</td>
<td>
<p>Current IRQL</p>
</td>
<td>
<p>Pool type</p>
</td>
<td>
<p>Size of allocation, in bytes</p>
</td>
<td>
<p>The current thread attempted to allocate the pool at an invalid IRQL.</p>
</td>
</tr>
<tr>
<td>
<p>0x09</p>
</td>
<td>
<p>Current IRQL</p>
</td>
<td>
<p>Pool type</p>
</td>
<td>
<p>Address of pool</p>
</td>
<td>
<p>The current thread attempted to free the pool at an invalid IRQL.</p>
</td>
</tr>
<tr>
<td>
<p>0x0A</p>
</td>
<td>
<p>Address of pool</p>
</td>
<td>
<p>Allocator's tag</p>
</td>
<td>
<p>Tag being used in the attempted free</p>
</td>
<td>
<p>The current thread attempted to free pool memory by using the wrong tag.</p>
<p>(The memory might belong to another component.)</p>
</td>
</tr>
<tr>
<td>
<p>0x0B,</p>
<p>0x0C,</p>
<p>or 0x0D</p>
</td>
<td>
<p>Address of pool</p>
</td>
<td>
<p>Pool allocation's tag</p>
</td>
<td>
<p>Bad quota process pointer</p>
</td>
<td>
<p>The current thread attempted to release a quota on a corrupted pool allocation.</p>
</td>
</tr>
<tr>
<td>
<p>0x40</p>
</td>
<td>
<p>Starting address</p>
</td>
<td>
<p>Start of system address space</p>
</td>
<td>
<p>0 </p>
</td>
<td>
<p>The current thread attempted to free the kernel pool at a user-mode address.</p>
</td>
</tr>
<tr>
<td>
<p>0x41</p>
</td>
<td>
<p>Starting address</p>
</td>
<td>
<p>Physical page frame</p>
</td>
<td>
<p>Highest physical page frame</p>
</td>
<td>
<p>The current thread attempted to free a non-allocated nonpaged pool address.</p>
</td>
</tr>
<tr>
<td>
<p>0x42</p>
<p> or 0x43</p>
</td>
<td>
<p>Address being freed</p>
</td>
<td>
<p>0 </p>
</td>
<td>
<p>0 </p>
</td>
<td>
<p>The current thread attempted to free a virtual address that was never in any pool.</p>
</td>
</tr>
<tr>
<td>
<p>0x44</p>
</td>
<td>
<p>Starting address</p>
</td>
<td>
<p>Reserved </p>
</td>
<td>
<p>0</p>
</td>
<td>
<p>The current thread attempted to free a non-allocated nonpaged pool address.</p>
</td>
</tr>
<tr>
<td>
<p>0x46</p>
</td>
<td>
<p>Starting address</p>
</td>
<td>
<p>0</p>
</td>
<td>
<p>0</p>
</td>
<td>
<p>The current thread attempted to free an invalid pool address. </p>
</td>
</tr>
<tr>
<td>
<p>0x47</p>
</td>
<td>
<p>Starting address</p>
</td>
<td>
<p>Physical page frame </p>
</td>
<td>
<p>Highest physical page frame </p>
</td>
<td>
<p>The current thread attempted to free a non-allocated nonpaged pool address. </p>
</td>
</tr>
<tr>
<td>
<p>0x48</p>
</td>
<td>
<p>Starting address </p>
</td>
<td>
<p>Reserved </p>
</td>
<td>
<p>Reserved </p>
</td>
<td>
<p>The current thread attempted to free a non-allocated paged pool address. </p>
</td>
</tr>
<tr>
<td>
<p>0x50</p>
</td>
<td>
<p>Starting address</p>
</td>
<td>
<p>Start offset, in pages, from beginning of paged pool</p>
</td>
<td>
<p>Size of paged pool, in bytes</p>
</td>
<td>
<p>The current thread attempted to free a non-allocated paged pool address.</p>
</td>
</tr>
<tr>
<td>
<p>0x60</p>
</td>
<td>
<p>Starting address </p>
</td>
<td>
<p>0 </p>
</td>
<td>
<p>0 </p>
</td>
<td>
<p>The current thread attempted to free an invalid contiguous memory address.</p>
<p>(The caller of <b>MmFreeContiguousMemory</b> is passing a bad pointer.) </p>
</td>
</tr>
<tr>
<td>
<p>0x99</p>
</td>
<td>
<p>Address that is being freed</p>
</td>
<td>
<p>0 </p>
</td>
<td>
<p>0 </p>
</td>
<td>
<p>The current thread attempted to free pool with an invalid address.</p>
<p>(This code can also indicate corruption in the pool header.)</p>
</td>
</tr>
<tr>
<td>
<p>0x9A</p>
</td>
<td>
<p>Pool type</p>
</td>
<td>
<p>Number of bytes requested</p>
</td>
<td>
<p>Pool tag</p>
</td>
<td>
<p>The current thread marked an allocation request MUST_SUCCEED.</p>
<p>(This pool type is no longer supported.)</p>
</td>
</tr>
<tr>
<td>
<p>0x9B</p>
</td>
<td>
<p>Pool type</p>
</td>
<td>
<p>Number of bytes requested</p>
</td>
<td>
<p>Caller's address</p>
</td>
<td>
<p>The current thread attempted to allocate a pool with a tag of 0</p>
<p>(This would be untrackable, and possibly corrupt the existing tag tables.)</p>
</td>
</tr>
<tr>
<td>
<p>0x9C</p>
</td>
<td>
<p>Pool type</p>
</td>
<td>
<p>Number of bytes requested</p>
</td>
<td>
<p>Caller's address</p>
</td>
<td>
<p>The current thread attempted to allocate a pool with a tag of "BIG".</p>
<p>(This would be untrackable and could possibly corrupt the existing tag tables.)</p>
</td>
</tr>
<tr>
<td>
<p>0x9D</p>
</td>
<td>
<p>Incorrect pool tag used</p>
</td>
<td>
<p>Pool type </p>
</td>
<td>
<p>Caller's address</p>
</td>
<td>
<p>The current thread attempted to allocate a pool with a tag that does not contain any letters or digits.  Using such tags makes tracking pool issues difficult. </p>
</td>
</tr>
<tr>
<td>
<p>0x41286</p>
</td>
<td>
<p>Reserved </p>
</td>
<td>
<p>Reserved </p>
</td>
<td>
<p>Start offset from the beginning of the paged pool, in pages </p>
</td>
<td>
<p>The current thread attempted to free a paged pool address in the middle of an allocation. </p>
</td>
</tr>
</table>
<p> </p>
<p>The _POOL_TYPE codes are enumerated in Ntddk.h. In particular, 0 indicates nonpaged pool and 1 indicates paged pool.</p>
<h2>Cause</h2>
<p>An invalid pool request has been made by the current thread. Typically this is at a bad IRQL level or double freeing the same memory allocation, etc.
</p>
<h2>Resolution</h2>
<p>Activate Driver Verifier with memory pool options enabled, to obtain more information about these errors and to locate the faulting driver.</p>
<p><b>Driver Verifier</b></p>
<p>Driver Verifier is a tool that runs in real time to examine the behavior of drivers.  If it see errors in the execution of driver code, it proactively creates an exception to allow that part of the driver code to be further scrutinized. The driver verifier manager is built into Windows and is available on all Windows PCs. To start  the driver verifier manager, type <i>Verifer</i> at a command prompt. You can configure which drivers you would like to verify. The code that verifies drivers adds overhead as it runs, so try and verify the smallest number of drivers as possible.  For more information, see Driver Verifier.</p>
<p><b>Windows Memory Diagnostics</b></p>
<p>In particular, for situations with memory pool corruption, run the Windows Memory Diagnostics tool, to try and isolate the physical memory as a cause. In the control panel search box, type Memory, and then click <b>Diagnose your computer's memory problems</b>.‌ After the test is run,  use Event viewer to view the results under  the System log. Look for the <i>MemoryDiagnostics-Results</i>
entry to view the results.</p>
<p> </p>
<p> </p>
</div>
<p style="text-align:left;font-family:Arial,sanserif;font-size:100%;color:black">
&#x00a9;&#x00a0;2016 Microsoft. All rights reserved.</p>

</body>
</html>
