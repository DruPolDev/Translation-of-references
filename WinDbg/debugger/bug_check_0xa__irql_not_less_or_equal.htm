<html xmlns:msxsl="urn:schemas-microsoft-com:xslt" xmlns:mssdk="winsdk" xmlns:script="urn:script" xmlns:build="urn:build" xmlns:MSHelp="http://msdn.microsoft.com/mshelp">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
<meta name="Description" content="The IRQL_NOT_LESS_OR_EQUAL bug check has a value of 0x0000000A."/>
<meta name="MSHAttr" content="PreferredSiteName:MSDN"/>
<meta name="MSHAttr" content="PreferredLib:/library/windows/hardware"/>
<title>Bug Check 0xA: IRQL_NOT_LESS_OR_EQUAL</title>

<meta name="MS-HAID" content="t04_bugs_00_92ed1f1a-43b9-453a-af0c-06260d719a7d.xml"/>


<link rel="STYLESHEET" type="text/css" HREF="../common/backsdk4.css"/>


</head>
<body>

<div id="mainSection">
<div class="clsServerSDKContent">
<h1><a id="debugger.bug_check_0xa__irql_not_less_or_equal"></a>Bug Check 0xA: IRQL_NOT_LESS_OR_EQUAL</h1>
</div>
<p>The IRQL_NOT_LESS_OR_EQUAL bug check has a value of 0x0000000A. This indicates that Microsoft Windows or a kernel-mode driver accessed paged memory at an invalid address while at a raised interrupt
request level (IRQL).  This is typically  either a bad pointer or a pageability problem.
</p>
<p>
<div class="alert"><b>Important </b>This topic is for programmers. If you are a customer who has received a blue screen error code while using your computer, see 
            <a href="http://windows.microsoft.com/en-us/windows-10/troubleshoot-blue-screen-errors" xmlns:loc="http://microsoft.com/wdcml/l10n">Troubleshoot blue screen errors</a>.</div>
</p>
<h2> IRQL_NOT_LESS_OR_EQUAL Parameters</h2>
<p>The following parameters are displayed on the blue screen.</p>
<table>
<tr>
<th>Parameter</th>
<th>Description</th>
</tr>
<tr>
<td>
<p>1</p>
</td>
<td>
<p>The virtual memory address that could not be accessed.
            </p>
<p>Use <a href="_pool.htm"><b>!pool</b></a> on this address to see whether it's Paged pool.
            These commands, may also be useful in gathering information about the failure: <a href="_pte.htm"><b>!pte</b></a>, <a href="_address.htm"><b>!address</b></a>, and <a href="ln__list_nearest_symbols_.htm"><b>ln (List Nearest Symbols)</b></a>.
</p>
</td>
</tr>
<tr>
<td>
<p>2</p>
</td>
<td>
<p>IRQL at time of the fault.</p>
<p>VALUES:
              </p>
<p>2 : The IRQL was DISPATCH_LEVEL at the time of the fault.
            END_VALUES
</p>
</td>
</tr>
<tr>
<td>
<p>3</p>
</td>
<td>
<p>Bitfield describing the operation that caused the fault.</p>
<p><b>Bit 0:</b></p>
<p>VALUES:</p>
<p>
        0: Read operation</p>
<p>
        1: Write operation</p>
<p><b>Bit 3:</b> (Only available on chipsets that support this level of reporting.) </p>
<p>VALUES:</p>
<p> 0:  Not an execute operation</p>
<p> 1: Execute operation</p><b>Bit 0 and Bit 3 combined values:</b><dl>
<dd>
<p>0x0 : Fault trying to READ from the address in parameter 1.</p>
</dd>
<dd>
<p>0x1 : Fault trying to WRITE to the address in  parameter 1.</p>
</dd>
<dd>
<p>0x8 : Fault trying to EXECUTE code from the address in  parameter 1.</p>
<p>This value is usually caused by:</p>
<ul>
<li>Calling a function that cannot be called at DISPATCH_LEVEL
                while at DISPATCH_LEVEL
</li>
<li>Forgetting to release a spinlock</li>
<li>Marking code as pageable when it must be non-pageable
                (e.g., because the code acquires a spinlock, or is called in a DPC)</li>
</ul>
</dd>
</dl>
</td>
</tr>
<tr>
<td>
<p>4</p>
</td>
<td>
<p>The instruction pointer at the time of the fault.</p>
<p>Use the <a href="ln__list_nearest_symbols_.htm"><b>ln (List Nearest Symbols)</b></a> command on this address to see the name of the function.</p>
</td>
</tr>
</table>
<p> </p>
<h2>Cause</h2>
<p>Bug check 0xA is usually
caused by kernel mode device drivers using improper addresses.</p>
<p>This bug check indicates that an attempt was made to access an invalid address while at a raised interrupt
request level (IRQL).  This is either a bad memory pointer or a pageability problem with the device driver code.
</p>
<dl>
<dd>1. If parameter 1 is less than 0x1000, then this is likely a NULL pointer dereference.</dd>
<dd>2. If !pool reports that parameter 1 is Paged pool, then the IRQL is too high to
   access this data.  Run at a lower IRQL or allocate the data in NonPagedPool.
</dd>
<dd>3. If parameter 3 indicates that this was an attempt to execute pageable code, then
   the IRQL is too high to call this function.  Run at a lower IRQL or do not
   mark the code as pageable.
</dd>
<dd>4. Otherwise, this may be a bad pointer, possibly caused by use-after-free
   or bit-flipping. Investigate the validity of parameter 1 with <a href="_pte.htm"><b>!pte</b></a>, <a href="_address.htm"><b>!address</b></a>, and <a href="ln__list_nearest_symbols_.htm"><b>ln (List Nearest Symbols)</b></a>.
</dd>
</dl>
<p></p>
<h2>Resolution</h2>
<p>If a kernel debugger is available, obtain a stack trace.</p>
<p><b>Gather Information</b></p>
<p>Examine the name of the driver if that was listed on the blue screen.</p>
<p>Check the System Log in Event Viewer for additional error messages that might help pinpoint the device or driver that is causing the error. For more information, see <a href="http://windows.microsoft.com/en-us/windows/what-information-event-logs-event-viewer#1TC=windows-7">Open Event Viewer</a>. Look for critical errors in the system log that occurred in the same time window as the blue screen.</p>
<p><b>Driver Verifier</b></p>
<p>Driver Verifier is a tool that runs in real time to examine the behavior of drivers. For example, Driver Verifier checks the use of memory resources, such as memory pools. If it sees errors in the execution of driver code, it proactively creates an exception to allow that part of the driver code to be further scrutinized. The driver verifier manager is built into Windows and is available on all Windows PCs. To start  the driver verifier manager, type <i>Verifer</i> at a command prompt. You can configure which drivers you would like to verify. The code that verifies drivers adds overhead as it runs, so try and verify the smallest number of drivers as possible.  For more information, see Driver Verifier.</p>
<p>Here is a debugging example:</p>
<div class="code"><span codelanguage=""><table>
<tr>
<th></th>
</tr>
<tr>
<td>
<pre>kd&gt; .bugcheck       [Lists bug check data.]
Bugcheck code 0000000a
Arguments 00000000 0000001c 00000000 00000000

kd&gt; kb [Lists the stack trace.]
ChildEBP RetAddr  Args to Child
8013ed5c 801263ba 00000000 00000000 e12ab000 NT!_DbgBreakPoint
8013eecc 801389ee 0000000a 00000000 0000001c NT!_KeBugCheckEx+0x194
8013eecc 00000000 0000000a 00000000 0000001c NT!_KiTrap0E+0x256
8013ed5c 801263ba 00000000 00000000 e12ab000
8013ef64 00000246 fe551aa1 ff690268 00000002 NT!_KeBugCheckEx+0x194

kd&gt; kv [Lists the trap frames.]
ChildEBP RetAddr  Args to Child
8013ed5c 801263ba 00000000 00000000 e12ab000 NT!_DbgBreakPoint (FPO: [0,0,0])
8013eecc 801389ee 0000000a 00000000 0000001c NT!_KeBugCheckEx+0x194
8013eecc 00000000 0000000a 00000000 0000001c NT!_KiTrap0E+0x256 (FPO: [0,0] TrapFrame @ 8013eee8)
8013ed5c 801263ba 00000000 00000000 e12ab000
8013ef64 00000246 fe551aa1 ff690268 00000002 NT!_KeBugCheckEx+0x194

kd&gt; .trap 8013eee8 [Gets the registers for the trap frame at the time of the fault.]
eax=dec80201 ebx=ffdff420 ecx=8013c71c edx=000003f8 esi=00000000 edi=87038e10
eip=00000000 esp=8013ef5c ebp=8013ef64 iopl=0         nv up ei pl nz na pe nc
cs=0008  ss=0010  ds=0023  es=0023  fs=0030  gs=0000             efl=00010202
ErrCode = 00000000
00000000 ???????????????    [The current instruction pointer is NULL.]

kd&gt; kb       [Gives the stack trace before the fault.]
ChildEBP RetAddr  Args to Child
8013ef68 fe551aa1 ff690268 00000002 fe5620d2 NT!_DbgBreakPoint
8013ef74 fe5620d2 fe5620da ff690268 80404690
NDIS!_EthFilterIndicateReceiveComplete+0x31
8013ef64 00000246 fe551aa1 ff690268 00000002 elnkii!_ElnkiiRcvInterruptDpc+0x1d0</pre>
</td>
</tr>
</table></span></div>
<h2>Remarks</h2>
<p>The error that generates this bug check usually occurs after the installation of a faulty device driver, system service, or BIOS.</p>
<p>If you encounter bug check 0xA while upgrading to a later version of Windows, this error might be caused by a device driver, a system service, a virus scanner, or a backup tool that is incompatible with the new version.</p>
<p><b>Resolving a faulty hardware problem:</b> If hardware has been added to the system recently, remove it to see if the error recurs. If existing hardware has failed, remove or replace the faulty component. You should run hardware diagnostics supplied by the system manufacturer. For details on these procedures, see the owner's manual for your computer. </p>
<p><b>Resolving a faulty system service problem:</b> Disable the service and confirm that this resolves the error. If so, contact the manufacturer of the system service about a possible update. If the error occurs during system startup, investigate the Windows repair options. For more information, see <a href="http://windows.microsoft.com/en-us/windows-10/windows-10-recovery-options">Recovery options in Windows 10</a>.</p>
<p><b>Resolving an antivirus software problem:</b> Disable the program and confirm that this resolves the error. If it does, contact the manufacturer of the program about a possible update. </p>
<p>For general blue screen troubleshooting information, see <a href="blue_screen_data.htm"><b>Blue Screen Data</b></a>.</p>
<p> </p>
<p> </p>
</div>
<p style="text-align:left;font-family:Arial,sanserif;font-size:100%;color:black">
&#x00a9;&#x00a0;2016 Microsoft. All rights reserved.</p>

</body>
</html>
