<html xmlns:msxsl="urn:schemas-microsoft-com:xslt" xmlns:mssdk="winsdk" xmlns:script="urn:script" xmlns:build="urn:build" xmlns:MSHelp="http://msdn.microsoft.com/mshelp">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
<meta name="Description" content="The MEMORY_MANAGEMENT bug check has a value of 0x0000001A. This indicates that a severe memory management error occurred."/>
<meta name="MSHAttr" content="PreferredSiteName:MSDN"/>
<meta name="MSHAttr" content="PreferredLib:/library/windows/hardware"/>
<title>Bug Check 0x1A: MEMORY_MANAGEMENT</title>

<meta name="MS-HAID" content="t04_bugs_00_a19cedae-b8ab-4885-af8d-7075e64de6fd.xml"/>


<link rel="STYLESHEET" type="text/css" HREF="../common/backsdk4.css"/>


</head>
<body>

<div id="mainSection">
<div class="clsServerSDKContent">
<h1><a id="debugger.bug_check_0x1a__memory_management"></a>Bug Check 0x1A: MEMORY_MANAGEMENT</h1>
</div>
<p>The MEMORY_MANAGEMENT bug check has a value of 0x0000001A. This indicates that a severe memory management error occurred.</p>
<p>
<div class="alert"><b>Important </b>This topic is for programmers. If you are a customer who has received a blue screen error code while using your computer, see 
            <a href="http://windows.microsoft.com/en-us/windows-10/troubleshoot-blue-screen-errors" xmlns:loc="http://microsoft.com/wdcml/l10n">Troubleshoot blue screen errors</a>.</div>
</p>
<h2> MEMORY_MANAGEMENT Parameters</h2>
<p></p>
<p>The following parameters are displayed on the blue screen. Parameter 1 is the only parameter of interest; this identifies the exact violation.</p>
<table>
<tr>
<th>Parameter 1</th>
<th>Cause of Error</th>
</tr>
<tr>
<td>
<p>0x1</p>
</td>
<td>
<p>The fork clone block reference count is corrupt. (This only occurs on checked builds of Windows.)</p>
</td>
</tr>
<tr>
<td>
<p>0x31</p>
</td>
<td>
<p>The image relocation fix-up table or code stream has been corrupted. This is probably a hardware error.</p>
</td>
</tr>
<tr>
<td>
<p>0x403</p>
</td>
<td>
<p>The page table and PFNs are out of sync . This is probably a hardware error, especially if parameters 3 &amp; 4 differ by only a single bit.</p>
</td>
</tr>
<tr>
<td>
<p>0x411</p>
</td>
<td>
<p>A page table entry (PTE) has been corrupted. Parameter 2 is the address of the PTE.</p>
</td>
</tr>
<tr>
<td>
<p>0x777</p>
</td>
<td>
<p>The caller is unlocking a system cache address that is not currently locked. (This address was either never mapped or is being unlocked twice.)</p>
</td>
</tr>
<tr>
<td>
<p>0x778</p>
</td>
<td>
<p>The system is using the very last system cache view address, instead of preserving it.</p>
</td>
</tr>
<tr>
<td>
<p>0x780</p>
<p>0x781</p>
</td>
<td>
<p>The PTEs mapping the argument system cache view have been corrupted.</p>
</td>
</tr>
<tr>
<td>
<p>0x1000</p>
</td>
<td>
<p>A caller of <b>MmGetSystemAddressForMdl*</b> tried to map a fully-cached physical page as non-cached. This action would cause a conflicting hardware translation buffer entry, and so it was refused by the operating system. Since the caller specified "bug check on failure" in the requesting MDL, the system had no choice but to issue a bug check in this instance.</p>
</td>
</tr>
<tr>
<td>
<p>0x1010</p>
</td>
<td>
<p>The caller is unlocking a pageable section that is not currently locked. (This section was either never locked or is being unlocked twice.)</p>
</td>
</tr>
<tr>
<td>
<p>0x1233</p>
</td>
<td>
<p>A driver tried to map a physical memory page that was not locked. This is illegal because the contents or attributes of the page can change at any time. This is a bug in the code that made the mapping call. Parameter 2 is the page frame number of the physical page that the driver attempted to map.</p>
</td>
</tr>
<tr>
<td>
<p>0x1234</p>
</td>
<td>
<p>The caller is trying lock a nonexistent pageable section.</p>
</td>
</tr>
<tr>
<td>
<p>0x1235</p>
</td>
<td>
<p>The caller is trying to protect an MDL with an invalid mapping.</p>
</td>
</tr>
<tr>
<td>
<p>0x3451</p>
</td>
<td>
<p>The PTEs of a kernel thread stack that has been swapped out are corrupted.</p>
</td>
</tr>
<tr>
<td>
<p>0x5003</p>
</td>
<td>
<p>The working set free list is corrupt.  This is probably a hardware error.</p>
</td>
</tr>
<tr>
<td>
<p>0x5100</p>
</td>
<td>
<p>The allocation bitmap is corrupt. The memory manager is about to overwrite a virtual address that was already in use.</p>
</td>
</tr>
<tr>
<td>
<p>0x8884</p>
</td>
<td>
<p>(Windows 7only).  Two pages on the standby list that were supposed to have identical page priority values do not, in fact, have identical page priority values. The differing values are captured in parameter 4.</p>
</td>
</tr>
<tr>
<td>
<p>0x8888</p>
<p>0x8889</p>
</td>
<td>
<p>Internal memory management structures are corrupted.</p>
</td>
</tr>
<tr>
<td>
<p>0x888A</p>
</td>
<td>
<p>Internal memory management structures (likely the PTE or PFN) are corrupted.</p>
</td>
</tr>
<tr>
<td>
<p>0x41283</p>
</td>
<td>
<p>The working set index encoded in the PTE is corrupted.</p>
</td>
</tr>
<tr>
<td>
<p>0x41284</p>
</td>
<td>
<p>A PTE or the working set list is corrupted.</p>
</td>
</tr>
<tr>
<td>
<p>0x41286</p>
</td>
<td>
<p>The caller is trying to free an invalid pool address.</p>
</td>
</tr>
<tr>
<td>
<p>0x41785</p>
</td>
<td>
<p>The working set list is corrupted.</p>
</td>
</tr>
<tr>
<td>
<p>0x41287</p>
</td>
<td>
<p>An illegal page fault occurred while holding working set synchronization. Parameter 2 contains the referenced virtual address.</p>
</td>
</tr>
<tr>
<td>
<p>0x41790</p>
</td>
<td>
<p>A page table page has been corrupted. On a 64 bit version of Windows, parameter 2
                  contains the address of the PFN for the corrupted page table page.
                  On a 32 bit version of Windows, parameter 2 contains a pointer to the number of used
                  PTEs, and parameter 3 contains the number of used PTEs.</p>
</td>
</tr>
<tr>
<td>
<p>0x41792</p>
</td>
<td>
<p>A  corrupted PTE has been detected. Parameter 2 contains the address of
                  the PTE. Parameters 3/4 contain the low/high parts of the PTE.</p>
</td>
</tr>
<tr>
<td>
<p>0x61940</p>
</td>
<td>
<p>A PDE has been unexpectedly invalidated.</p>
</td>
</tr>
<tr>
<td>
<p>0x61946</p>
</td>
<td>
<p>The MDL being created is flawed.  This almost always means the driver calling <b>MmProbeAndLockPages</b> is at fault.  Typically the driver is attempting to create a Write MDL when it is being asked to process a paging Read.</p>
</td>
</tr>
<tr>
<td>
<p>0x03030303</p>
</td>
<td>
<p>The boot loader is broken. (This value applies only to Intel Itanium machines.)</p>
</td>
</tr>
<tr>
<td>
<p>Other
       </p>
</td>
<td>
<p>An unknown memory management error occurred.</p>
</td>
</tr>
</table>
<p> </p>
<p> </p>
<p> </p>
</div>
<p style="text-align:left;font-family:Arial,sanserif;font-size:100%;color:black">
&#x00a9;&#x00a0;2016 Microsoft. All rights reserved.</p>

</body>
</html>
