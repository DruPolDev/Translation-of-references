<html xmlns:msxsl="urn:schemas-microsoft-com:xslt" xmlns:mssdk="winsdk" xmlns:script="urn:script" xmlns:build="urn:build" xmlns:MSHelp="http://msdn.microsoft.com/mshelp">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
<meta name="Description" content="Identifying the Caller From the Server Thread"/>
<meta name="MSHAttr" content="PreferredSiteName:MSDN"/>
<meta name="MSHAttr" content="PreferredLib:/library/windows/hardware"/>
<title>Identifying the Caller From the Server Thread</title>

<meta name="MS-HAID" content="t11_rpc_acpi_045ac5d9-af8d-48d9-bcfa-0fd3fe2d1a60.xml"/>


<link rel="STYLESHEET" type="text/css" HREF="../common/backsdk4.css"/>


</head>
<body>

<div id="mainSection">
<div class="clsServerSDKContent">
<h1><a id="debugger.identifying_the_caller_from_the_server_thread"></a>Identifying the Caller From the Server Thread</h1>
</div>
<h2><a id="ddk_identifying_the_caller_from_the_server_thread_dbg"></a><a id="DDK_IDENTIFYING_THE_CALLER_FROM_THE_SERVER_THREAD_DBG"></a></h2>
<p>It is possible to determine what made a given RPC call, even if the only information you have is the server thread that serviced the call.</p>
<p>This can be very useful -- for example, to find out who passed invalid parameters to an RPC call.</p>
<p>Depending on which protocol sequence is used by this particular call, you can get varying degrees of detail. Some protocols (such as NetBios) do not have this information at all.</p>
<p class="proch"><img src="../common/wedge.gif" alt=""/><b>Identifying the caller from the server thread
     </b></p>
<ol>
<li>
<p>Start a user-mode debugger with the server thread as the target.</p>
</li>
<li>Get the process ID by using the <a href="___process_status_.htm"><b>| (Process Status)</b></a> command:<div class="code"><span codelanguage=""><table>
<tr>
<th></th>
</tr>
<tr>
<td>
<pre>0:001&gt; |
  0     id: 3d4 name: rtsvr.exe</pre>
</td>
</tr>
</table></span></div>
</li>
<li>Get the active calls in this process by using the <a href="_rpcexts_getcallinfo.htm"><b>!rpcexts.getcallinfo</b></a> extension. (See the reference page for an explanation of the syntax.) You need to supply the process ID of 0x3D4:<div class="code"><span codelanguage=""><table>
<tr>
<th></th>
</tr>
<tr>
<td>
<pre>0:001&gt; !rpcexts.getcallinfo 0 0 FFFF 3d4
Searching for call info ...
PID  CELL ID   ST PNO IFSTART  THRDCELL  CALLFLAG CALLID   LASTTIME CONN/CLN
----------------------------------------------------------------------------
03d4 0000.0004 02 000 19bb5061 0000.0002 00000001 00000001 00a1aced 0000.0003</pre>
</td>
</tr>
</table></span></div>
<p>Look for calls with status 02 or 01 (dispatched or active). In this example, the process only has one call. If there were more, you would have to use the <a href="_rpcexts_getdbgcell.htm"><b>!rpcexts.getdbgcell</b></a> extension with the cell number in the THRDCELL column. This would allow you to examine the thread IDs so you could determine which call you were interested in.</p>
</li>
<li>After you know which call you are interested in, look at the cell number in the CONN/CLN column. This is the cell ID of the connection object. In this case, the cell number is 0000.0003. Pass this cell number and the process ID to <b>!rpcexts.getdbgcell</b>:<div class="code"><span codelanguage=""><table>
<tr>
<th></th>
</tr>
<tr>
<td>
<pre>0:001&gt; !rpcexts.getdbgcell 3d4 0.3
Getting cell info ...
Connection
Connection flags: Exclusive
Authentication Level: Default
Authentication Service: None
Last Transmit Fragment Size: 24 (0x6F56D)
Endpoint for the connection: 0x0.1
Last send time (in seconds since boot):10595.565 (0x2963.235)
Last receive time (in seconds since boot):10595.565 (0x2963.235)
Getting endpoint info ...
Process object for caller is 0xFF9DF5F0</pre>
</td>
</tr>
</table></span></div>
</li>
</ol>
<p>This extension will display all the information available about the client of this connection. The amount of actual information will vary, depending on the transport being used.</p>
<p>In this example, local named pipes are being used as the transport and the process object address of the caller is displayed. If you attach a kernel debugger (or start a local kernel debugger), you can use the <a href="_process.htm"><b>!process</b></a> extension to interpret this process address.</p>
<p>If LRPC is used as the transport, the process ID and thread ID of the caller will be displayed.</p>
<p>If TCP is used as the transport, the IP address of the caller will be displayed.</p>
<p>If remote named pipes are used as the transport, no information will be available.</p>
<div class="alert"><b>Note</b>    The previous example shows how to find the client thread if you know the server thread. For an example of the <u>reverse</u> technique, see <a href="analyzing_a_stuck_call_problem.htm">Analyzing a Stuck Call Problem</a>.</div>
<div> </div>
<p> </p>
<p> </p>
<p><a href="mailto:wsddocfb@microsoft.com?subject=Documentation%20feedback [debugger\debugger]:%20Identifying the Caller From the Server Thread%20 RELEASE:%20(3/16/2017)&amp;body=%0A%0APRIVACY STATEMENT%0A%0AWe use your feedback to improve the documentation. We don't use your email address for any other purpose, and we'll remove your email address from our system after the issue that you're reporting is fixed. While we're working to fix this issue, we might send you an email message to ask for more info. Later, we might also send you an email message to let you know that we've addressed your feedback.%0A%0AFor more info about Microsoft's privacy policy, see http://privacy.microsoft.com/en-us/default.aspx." title="Send comments about this topic to Microsoft">Send comments about this topic to Microsoft</a></p>
</div>
<p style="text-align:left;font-family:Arial,sanserif;font-size:100%;color:black">
&#x00a9;&#x00a0;2016 Microsoft. All rights reserved.</p>

</body>
</html>
