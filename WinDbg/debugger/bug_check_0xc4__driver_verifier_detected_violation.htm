<html xmlns:msxsl="urn:schemas-microsoft-com:xslt" xmlns:mssdk="winsdk" xmlns:script="urn:script" xmlns:build="urn:build" xmlns:MSHelp="http://msdn.microsoft.com/mshelp">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
<meta name="Description" content="The DRIVER_VERIFIER_DETECTED_VIOLATION bug check has a value of 0x000000C4. This is the general bug check code for fatal errors found by Driver Verifier. For more information, see Handling a Bug Check When Driver Verifier is Enabled."/>
<meta name="MSHAttr" content="PreferredSiteName:MSDN"/>
<meta name="MSHAttr" content="PreferredLib:/library/windows/hardware"/>
<title>Bug Check 0xC4: DRIVER_VERIFIER_DETECTED_VIOLATION</title>

<meta name="MS-HAID" content="t06_bugs_B0_77bda7e9-4f41-49e9-86db-04446dc9c7b7.xml"/>


<link rel="STYLESHEET" type="text/css" HREF="../common/backsdk4.css"/>


</head>
<body>

<div id="mainSection">
<div class="clsServerSDKContent">
<h1><a id="debugger.bug_check_0xc4__driver_verifier_detected_violation"></a>Bug Check 0xC4: DRIVER_VERIFIER_DETECTED_VIOLATION</h1>
</div>
<p>The DRIVER_VERIFIER_DETECTED_VIOLATION bug check has a value of 0x000000C4. This is the general bug check code for fatal errors found by  Driver Verifier.  For more information, see <a href="handling_a_bug_check_when_driver_verifier_is_enabled.htm">Handling a Bug Check When Driver Verifier is Enabled</a>.</p>
<p>
<div class="alert"><b>Important </b>This topic is for programmers. If you are a customer who has received a blue screen error code while using your computer, see 
            <a href="http://windows.microsoft.com/en-us/windows-10/troubleshoot-blue-screen-errors" xmlns:loc="http://microsoft.com/wdcml/l10n">Troubleshoot blue screen errors</a>.</div>
</p>
<h2> DRIVER_VERIFIER_DETECTED_VIOLATION Parameters</h2>
<p>Four bug check parameters are displayed on the blue screen. Parameter 1 identifies the type of violation. The meaning of the remaining parameters varies with the value of Parameter 1. The parameter values are described in the following table.</p>
<div class="alert"><b>Note</b>  If you have trouble viewing all 5 columns in this table, try the following: <ul>
<li>Expand your browser window to full size. </li>
<li>Place the cursor in the table and use the arrow keys to scroll left and right. </li>
<li>Or use the <a href="http://msdn.microsoft.com/en-us/library/ff560187(v=vs.85).aspx">MSDN Library version</a> of this page. </li>
</ul>
</div>
<div> </div>
<table>
<tr>
<th>Parameter 1</th>
<th>Parameter 2</th>
<th>Parameter 3</th>
<th>Parameter 4</th>
<th>Cause of Error</th>
</tr>
<tr>
<td>
<p>0x00</p>
</td>
<td>
<p>Current IRQL</p>
</td>
<td>
<p>Pool type</p>
</td>
<td>
<p>0 </p>
</td>
<td>
<p>The driver requested a zero-byte pool allocation. </p>
</td>
</tr>
<tr>
<td>
<p>0x01</p>
</td>
<td>
<p>Current IRQL</p>
</td>
<td>
<p>Pool type</p>
</td>
<td>
<p>Size of allocation, in bytes</p>
</td>
<td>
<p>The driver attempted to allocate paged memory with IRQL &gt; APC_LEVEL. </p>
</td>
</tr>
<tr>
<td>
<p>0x02</p>
</td>
<td>
<p>Current IRQL</p>
</td>
<td>
<p>Pool type</p>
</td>
<td>
<p>Size of allocation, in bytes</p>
</td>
<td>
<p>The driver attempted to allocate nonpaged memory with IRQL &gt; DISPATCH_LEVEL. </p>
</td>
</tr>
<tr>
<td>
<p>0x10</p>
</td>
<td>
<p>Bad Address</p>
</td>
<td>
<p>0 </p>
</td>
<td>
<p>0 </p>
</td>
<td>
<p>The driver attempted to free an address that was not returned from an allocate call. </p>
</td>
</tr>
<tr>
<td>
<p>0x11</p>
</td>
<td>
<p>Current IRQL</p>
</td>
<td>
<p>Pool type</p>
</td>
<td>
<p>Address of pool</p>
</td>
<td>
<p>The driver attempted to free paged pool with IRQL &gt; APC_LEVEL. </p>
</td>
</tr>
<tr>
<td>
<p>0x12</p>
</td>
<td>
<p>Current IRQL</p>
</td>
<td>
<p>Pool type</p>
</td>
<td>
<p>Address of pool</p>
</td>
<td>
<p>The driver attempted to free nonpaged pool with IRQL &gt; DISPATCH_LEVEL. </p>
</td>
</tr>
<tr>
<td>
<p>0x13 or</p>
<p>0x14</p>
</td>
<td>
<p>Reserved </p>
</td>
<td>
<p>Pointer to pool header</p>
</td>
<td>
<p>Pool header contents</p>
</td>
<td>
<p>The driver attempted to free memory pool which was already freed.  </p>
</td>
</tr>
<tr>
<td>
<p>0x16</p>
</td>
<td>
<p>Reserved</p>
</td>
<td>
<p>Pool address</p>
</td>
<td>
<p>0 </p>
</td>
<td>
<p>The driver attempted to free pool at a bad address, or the driver passed invalid parameters to a memory routine. </p>
</td>
</tr>
<tr>
<td>
<p>0x30</p>
</td>
<td>
<p>Current IRQL</p>
</td>
<td>
<p>Requested IRQL</p>
</td>
<td>
<p>0 </p>
</td>
<td>
<p>The driver passed an invalid parameter to <b>KeRaiseIrql</b>. </p>
<p>(The parameter was either a value lower than the current IRQL, or a value higher than HIGH_LEVEL. This may be the result of using an uninitialized parameter.) </p>
</td>
</tr>
<tr>
<td>
<p>0x31</p>
</td>
<td>
<p>Current IRQL</p>
</td>
<td>
<p>Requested IRQL</p>
</td>
<td>
<p><b>0:</b>  New IRQL is bad</p>
<p><b>1:</b>  New IRQL is invalid inside a DPC routine</p>
</td>
<td>
<p>The driver passed an invalid parameter to <b>KeLowerIrql</b>. </p>
<p>(The parameter was either a value higher than the current IRQL, or a value higher than HIGH_LEVEL. This may be the result of using an uninitialized parameter.) </p>
</td>
</tr>
<tr>
<td>
<p>0x32</p>
</td>
<td>
<p>Current IRQL</p>
</td>
<td>
<p>Spin lock address</p>
</td>
<td>
<p>0 </p>
</td>
<td>
<p>The driver called <b>KeReleaseSpinLock</b> at an IRQL other than DISPATCH_LEVEL.</p>
<p>(This may be due to a double-release of a spin lock.) </p>
</td>
</tr>
<tr>
<td>
<p>0x33</p>
</td>
<td>
<p>Current IRQL</p>
</td>
<td>
<p>Fast mutex address</p>
</td>
<td>
<p>0 </p>
</td>
<td>
<p>The driver attempted to acquire fast mutex with IRQL &gt; APC_LEVEL. </p>
</td>
</tr>
<tr>
<td>
<p>0x34</p>
</td>
<td>
<p>Current IRQL</p>
</td>
<td>
<p>Fast mutex address</p>
</td>
<td>
<p>0 </p>
</td>
<td>
<p>The driver attempted to release fast mutex at an IRQL other than APC_LEVEL.  </p>
</td>
</tr>
<tr>
<td>
<p>0x35</p>
</td>
<td>
<p>Current IRQL</p>
</td>
<td>
<p>Spin lock address</p>
</td>
<td>
<p>Old IRQL</p>
</td>
<td>
<p>The kernel released a spin lock with IRQL not equal to DISPATCH_LEVEL. </p>
</td>
</tr>
<tr>
<td>
<p>0x36</p>
</td>
<td>
<p>Current IRQL</p>
</td>
<td>
<p>Spin lock number</p>
</td>
<td>
<p>Old IRQL</p>
</td>
<td>
<p>The kernel released a queued spin lock with IRQL not equal to DISPATCH_LEVEL. </p>
</td>
</tr>
<tr>
<td>
<p>0x37</p>
</td>
<td>
<p>Current IRQL</p>
</td>
<td>
<p>Thread APC disable count</p>
</td>
<td>
<p>Resource</p>
</td>
<td>
<p>The driver tried to acquire a resource, but APCs are not disabled. </p>
</td>
</tr>
<tr>
<td>
<p>0x38</p>
</td>
<td>
<p>Current IRQL</p>
</td>
<td>
<p>Thread APC disable count</p>
</td>
<td>
<p>Resource</p>
</td>
<td>
<p>The driver tried to release a resource, but APCs are not disabled. </p>
</td>
</tr>
<tr>
<td>
<p>0x39</p>
</td>
<td>
<p>Current IRQL</p>
</td>
<td>
<p>Thread APC disable count</p>
</td>
<td>
<p>Mutex</p>
</td>
<td>
<p>The driver tried to acquire a mutex "unsafe" with IRQL not equal to APC_LEVEL on entry. </p>
</td>
</tr>
<tr>
<td>
<p>0x3A</p>
</td>
<td>
<p>Current IRQL</p>
</td>
<td>
<p>Thread APC disable count</p>
</td>
<td>
<p>Mutex</p>
</td>
<td>
<p>The driver tried to release a mutex "unsafe" with IRQL not equal to APC_LEVEL on entry. </p>
</td>
</tr>
<tr>
<td>
<p>0x3C</p>
</td>
<td>
<p>Handle passed to routine</p>
</td>
<td>
<p>Object type</p>
</td>
<td>
<p>0 </p>
</td>
<td>
<p>The driver called <b>ObReferenceObjectByHandle</b> with a bad handle. </p>
</td>
</tr>
<tr>
<td>
<p>0x3D</p>
</td>
<td>
<p>0 </p>
</td>
<td>
<p>0 </p>
</td>
<td>
<p>Address of the bad resource </p>
</td>
<td>
<p>The driver passed a bad (unaligned) resource to <b>ExAcquireResourceExclusive</b>. </p>
</td>
</tr>
<tr>
<td>
<p>0x3E</p>
</td>
<td>
<p>0</p>
</td>
<td>
<p>0</p>
</td>
<td>
<p>0</p>
</td>
<td>
<p>The driver called <b>KeLeaveCriticalRegion</b> for a thread that is not currently in a critical region.</p>
</td>
</tr>
<tr>
<td>
<p>0x3F</p>
</td>
<td>
<p>Object address</p>
</td>
<td>
<p>New object reference count.</p>
<p><b>-1:</b>  dereference case</p>
<p><b>1: </b> reference case</p>
</td>
<td>
<p>0</p>
</td>
<td>
<p>The driver applied  <b>ObReferenceObject</b> to an object that has a reference count of zero, or the driver applied <b>ObDereferenceObject</b> to an object that has a reference count of zero. </p>
</td>
</tr>
<tr>
<td>
<p>0x40</p>
</td>
<td>
<p>Current IRQL</p>
</td>
<td>
<p>Spin lock address</p>
</td>
<td>
<p>0 </p>
</td>
<td>
<p>The driver called <b>KeAcquireSpinLockAtDpcLevel</b> with IRQL &lt; DISPATCH_LEVEL. </p>
</td>
</tr>
<tr>
<td>
<p>0x41</p>
</td>
<td>
<p>Current IRQL</p>
</td>
<td>
<p>Spin lock address</p>
</td>
<td>
<p>0 </p>
</td>
<td>
<p>The driver called <b>KeReleaseSpinLockFromDpcLevel</b> with IRQL &lt; DISPATCH_LEVEL. </p>
</td>
</tr>
<tr>
<td>
<p>0x42</p>
</td>
<td>
<p>Current IRQL</p>
</td>
<td>
<p>Spin lock address</p>
</td>
<td>
<p>0 </p>
</td>
<td>
<p>The driver called <b>KeAcquireSpinLock</b> with IRQL &gt; DISPATCH_LEVEL. </p>
</td>
</tr>
<tr>
<td>
<p>0x51</p>
</td>
<td>
<p>Base address of allocation</p>
</td>
<td>
<p>Address of the reference beyond the allocation</p>
</td>
<td>
<p>Number of charged bytes</p>
</td>
<td>
<p>The driver attempted to free memory after having written past the end of the allocation.  A bug check with this parameter occurs only when the <b>Pool Tracking</b> option of Driver Verifier is active. </p>
</td>
</tr>
<tr>
<td>
<p>0x52</p>
</td>
<td>
<p>Base address of allocation</p>
</td>
<td>
<p>Reserved</p>
</td>
<td>
<p>Number of charged bytes</p>
</td>
<td>
<p>The driver attempted to free memory after having written past the end of the allocation.  A bug check with this parameter occurs only when the <b>Pool Tracking</b> option of Driver Verifier is active. </p>
</td>
</tr>
<tr>
<td>
<p>0x53,</p>
<p>0x54,</p>
<p>or 0x59</p>
</td>
<td>
<p>Base address of allocation</p>
</td>
<td>
<p>Reserved  </p>
</td>
<td>
<p>Reserved  </p>
</td>
<td>
<p>The driver attempted to free memory after having written past the end of the allocation.  A bug check with this parameter occurs only when the <b>Pool Tracking</b> option of Driver Verifier is active. </p>
</td>
</tr>
<tr>
<td>
<p>0x60</p>
</td>
<td>
<p>Bytes allocated from paged pool</p>
</td>
<td>
<p>Bytes allocated from nonpaged pool</p>
</td>
<td>
<p>Total number of allocations that were not freed</p>
</td>
<td>
<p>The driver is unloading without first freeing its pool allocations. A bug check with this parameter occurs only when the <b>Pool Tracking</b> option of Driver Verifier is active.</p>
</td>
</tr>
<tr>
<td>
<p>0x61</p>
</td>
<td>
<p>Bytes allocated from paged pool</p>
</td>
<td>
<p>Bytes allocated from nonpaged pool</p>
</td>
<td>
<p>Total number of allocations that were not freed</p>
</td>
<td>
<p>A driver thread is attempting to allocate pool memory while the driver is unloading.  A bug check with this parameter occurs only when the <b>Pool Tracking</b> option of Driver Verifier is active.</p>
</td>
</tr>
<tr>
<td>
<p>0x62</p>
</td>
<td>
<p>Name of the driver</p>
</td>
<td>
<p>Reserved </p>
</td>
<td>
<p>Total number of allocations that were not freed, including both paged and nonpaged pool</p>
</td>
<td>
<p>The driver is unloading without first freeing its pool allocations.  A bug check with this parameter occurs only when the <b>Pool Tracking</b> option of Driver Verifier is active.</p>
</td>
</tr>
<tr>
<td>
<p>0x70</p>
</td>
<td>
<p>Current IRQL</p>
</td>
<td>
<p>MDL address</p>
</td>
<td>
<p>Access mode</p>
</td>
<td>
<p>The driver called <b>MmProbeAndLockPages</b> with IRQL &gt; DISPATCH_LEVEL. </p>
</td>
</tr>
<tr>
<td>
<p>0x71</p>
</td>
<td>
<p>Current IRQL</p>
</td>
<td>
<p>MDL address</p>
</td>
<td>
<p>Process address</p>
</td>
<td>
<p>The driver called <b>MmProbeAndLockProcessPages</b> with IRQL &gt; DISPATCH_LEVEL. </p>
</td>
</tr>
<tr>
<td>
<p>0x72</p>
</td>
<td>
<p>Current IRQL</p>
</td>
<td>
<p>MDL address</p>
</td>
<td>
<p>Process address</p>
</td>
<td>
<p>The driver called <b>MmProbeAndLockSelectedPages</b>  with IRQL &gt; DISPATCH_LEVEL. </p>
</td>
</tr>
<tr>
<td>
<p>0x73</p>
</td>
<td>
<p>Current IRQL</p>
</td>
<td>
<p>
        In 32-bit Windows: Low 32 bits of the physical address</p>
<p>
        In 64-bit Windows: the 64-bit physical address</p>
</td>
<td>
<p>Number of bytes</p>
</td>
<td>
<p>The driver called <b>MmMapIoSpace</b> with IRQL &gt; DISPATCH_LEVEL. </p>
</td>
</tr>
<tr>
<td>
<p>0x74</p>
</td>
<td>
<p>Current IRQL</p>
</td>
<td>
<p>MDL address</p>
</td>
<td>
<p>Access mode</p>
</td>
<td>
<p>The driver called <b>MmMapLockedPages</b> in kernel mode with IRQL &gt; DISPATCH_LEVEL. </p>
</td>
</tr>
<tr>
<td>
<p>0x75</p>
</td>
<td>
<p>Current IRQL</p>
</td>
<td>
<p>MDL address</p>
</td>
<td>
<p>Access mode</p>
</td>
<td>
<p>The driver called <b>MmMapLockedPages</b> in user mode with IRQL &gt; APC_LEVEL. </p>
</td>
</tr>
<tr>
<td>
<p>0x76</p>
</td>
<td>
<p>Current IRQL</p>
</td>
<td>
<p>MDL address</p>
</td>
<td>
<p>Access mode</p>
</td>
<td>
<p>The driver called <b>MmMapLockedPagesSpecifyCache</b> in kernel mode with IRQL &gt; DISPATCH_LEVEL. </p>
</td>
</tr>
<tr>
<td>
<p>0x77</p>
</td>
<td>
<p>Current IRQL</p>
</td>
<td>
<p>MDL address</p>
</td>
<td>
<p>Access mode</p>
</td>
<td>
<p>The driver called <b>MmMapLockedPagesSpecifyCache</b> in user mode with IRQL &gt; APC_LEVEL. </p>
</td>
</tr>
<tr>
<td>
<p>0x78</p>
</td>
<td>
<p>Current IRQL</p>
</td>
<td>
<p>MDL address</p>
</td>
<td>
<p>0 </p>
</td>
<td>
<p>The driver called <b>MmUnlockPages</b> with IRQL &gt; DISPATCH_LEVEL. </p>
</td>
</tr>
<tr>
<td>
<p>0x79</p>
</td>
<td>
<p>Current IRQL</p>
</td>
<td>
<p>Virtual address being unmapped</p>
</td>
<td>
<p>MDL address</p>
</td>
<td>
<p>The driver called <b>MmUnmapLockedPages</b> in kernel mode with IRQL &gt; DISPATCH_LEVEL. </p>
</td>
</tr>
<tr>
<td>
<p>0x7A</p>
</td>
<td>
<p>Current IRQL</p>
</td>
<td>
<p>Virtual address being unmapped</p>
</td>
<td>
<p>MDL address</p>
</td>
<td>
<p>The driver called <b>MmUnmapLockedPages</b> in user mode with IRQL &gt; APC_LEVEL. </p>
</td>
</tr>
<tr>
<td>
<p>0x7B</p>
</td>
<td>
<p>Current IRQL</p>
</td>
<td>
<p>Virtual address being unmapped</p>
</td>
<td>
<p>Number of bytes</p>
</td>
<td>
<p>The driver called <b>MmUnmapIoSpace</b> with IRQL &gt; APC_LEVEL. </p>
</td>
</tr>
<tr>
<td>
<p>0x7C</p>
</td>
<td>
<p>MDL address</p>
</td>
<td>
<p>MDL flags</p>
</td>
<td>
<p>0 </p>
</td>
<td>
<p>The driver called <b>MmUnlockPages</b>, and passed an MDL whose pages were never successfully locked. </p>
</td>
</tr>
<tr>
<td>
<p>0x7D</p>
</td>
<td>
<p>MDL address</p>
</td>
<td>
<p>MDL flags</p>
</td>
<td>
<p>0 </p>
</td>
<td>
<p>The driver called <b>MmUnlockPages</b>, and passed an MDL whose pages are from nonpaged pool.</p>
<p>(These should never be unlocked.) </p>
</td>
</tr>
<tr>
<td>
<p>0x7E</p>
</td>
<td>
<p>Current IRQL</p>
</td>
<td>
<p> DISPATCH_LEVEL</p>
</td>
<td>
<p>0</p>
</td>
<td>
<p>The driver called <b>MmAllocatePagesForMdl</b>,  <b>MmAllocatePagesForMdlEx</b>, or <b>MmFreePagesFromMdl</b>             with IRQL &gt; DISPATCH_LEVEL.</p>
</td>
</tr>
<tr>
<td>
<p>0x7F</p>
</td>
<td>
<p>Current IRQL</p>
</td>
<td>
<p>MDL address</p>
</td>
<td>
<p>MDL flags</p>
</td>
<td>
<p>The driver called <b>BuildMdlForNonPagedPool</b> and passed an MDL whose pages are from paged pool.
</p>
</td>
</tr>
<tr>
<td>
<p>0x80</p>
</td>
<td>
<p>Current IRQL</p>
</td>
<td>
<p>Event address</p>
</td>
<td>
<p>0 </p>
</td>
<td>
<p>The driver called <b>KeSetEvent</b> with IRQL &gt; DISPATCH_LEVEL. </p>
</td>
</tr>
<tr>
<td>
<p>0x81</p>
</td>
<td>
<p>MDL address</p>
</td>
<td>
<p>MDL flags</p>
</td>
<td>
<p>0 </p>
</td>
<td>
<p>The driver called <b>MmMapLockedPages</b>.</p>
<p>(You should use <b>MmMapLockedPagesSpecifyCache</b> instead, with the <i>BugCheckOnFailure</i> parameter set to <b>FALSE</b>.)</p>
</td>
</tr>
<tr>
<td>
<p>0x82</p>
</td>
<td>
<p>MDL address</p>
</td>
<td>
<p>MDL flags</p>
</td>
<td>
<p>0 </p>
</td>
<td>
<p>The driver called <b>MmMapLockedPagesSpecifyCache</b> with the <i>BugCheckOnFailure</i> parameter equal to <b>TRUE</b>.</p>
<p>(This parameter should be set to <b>FALSE</b>.)</p>
</td>
</tr>
<tr>
<td>
<p>0x83</p>
</td>
<td>
<p>Start of physical address range to map</p>
</td>
<td>
<p>Number of bytes to map</p>
</td>
<td>
<p>First page frame number that isn't locked down</p>
</td>
<td>
<p>The driver called <b>MmMapIoSpace</b> without having locked down the MDL pages.  The physical pages represented by the physical address range being mapped must have been locked down prior to making this call.</p>
</td>
</tr>
<tr>
<td>
<p>0x85</p>
</td>
<td>
<p>MDL address</p>
</td>
<td>
<p>Number of pages to map</p>
</td>
<td>
<p>First page frame number that isn't locked down</p>
</td>
<td>
<p>The driver called <b>MmMapLockedPages</b> without having locked down the MDL pages. </p>
</td>
</tr>
<tr>
<td>
<p>0x89</p>
</td>
<td>
<p>MDL address</p>
</td>
<td>
<p>Pointer to the non-memory page in the MDL</p>
</td>
<td>
<p>The non-memory page number in the MDL</p>
</td>
<td>
<p>An MDL is not marked as "I/O", but it contains non-memory page addresses.</p>
</td>
</tr>
<tr>
<td>
<p>0x91</p>
</td>
<td>
<p>Reserved </p>
</td>
<td>
<p>Reserved </p>
</td>
<td>
<p>Reserved </p>
</td>
<td>
<p>The driver switched stacks using a method that is not supported by the operating system.  The only supported way to extend a kernel mode stack is by using <b>KeExpandKernelStackAndCallout</b>.   </p>
</td>
</tr>
<tr>
<td>
<p>0xA0 (Windows Server 2003 and later operating systems only)</p>
</td>
<td>
<p>Pointer to the IRP making the read or write request</p>
</td>
<td>
<p>Device object of the lower device</p>
</td>
<td>
<p>Number of the sector in which the error was detected</p>
</td>
<td>
<p>A cyclic redundancy check (CRC) error was detected on a hard disk.   A bug check with this parameter occurs only when the <b>Disk Integrity Checking</b> option of Driver Verifier is active. </p>
</td>
</tr>
<tr>
<td>
<p>0xA1 (Windows Server 2003 and later operating systems only)</p>
</td>
<td>
<p>Copy of the IRP making the read or write request. (The actual IRP has been completed.)</p>
</td>
<td>
<p>Device object of the lower device</p>
</td>
<td>
<p>Number of the sector in which the error was detected</p>
</td>
<td>
<p>A CRC error was detected on a sector (asynchronously).  A bug check with this parameter occurs only when the <b>Disk Integrity Checking</b> option of Driver Verifier is active. </p>
</td>
</tr>
<tr>
<td>
<p>0xA2 (Windows Server 2003 and later operating systems only)</p>
</td>
<td>
<p>IRP making the read or write request, or a copy of this IRP</p>
</td>
<td>
<p>Device object of the lower device</p>
</td>
<td>
<p>Number of the sector in which the error was detected</p>
</td>
<td>
<p>The CRCDISK checksum copies don't match.  This could be a paging error.  A bug check with this parameter occurs only when the <b>Disk Integrity Checking</b> option of Driver Verifier is active. </p>
</td>
</tr>
<tr>
<td>
<p>0xB0 (Windows Vista and later operating systems only)</p>
</td>
<td>
<p>MDL address</p>
</td>
<td>
<p>MDL flags</p>
</td>
<td>
<p>Incorrect MDL flags</p>
</td>
<td>
<p>The driver called <b>MmProbeAndLockPages</b> for an MDL with incorrect flags.  For example, the driver passed an MDL created by <b>MmBuildMdlForNonPagedPool</b> to <b>MmProbeAndLockPages</b>.</p>
</td>
</tr>
<tr>
<td>
<p>0xB1  (Windows Vista and later operating systems only)</p>
</td>
<td>
<p>MDL address</p>
</td>
<td>
<p>MDL flags</p>
</td>
<td>
<p>Incorrect MDL flags</p>
</td>
<td>
<p>The driver called <b>MmProbeAndLockProcessPages</b> for an MDL with incorrect flags.  For example, the driver passed an MDL created by <b>MmBuildMdlForNonPagedPool</b> to <b>MmProbeAndLockProcessPages</b>.</p>
</td>
</tr>
<tr>
<td>
<p>0xB2  (Windows Vista and later operating systems only)</p>
</td>
<td>
<p>MDL address</p>
</td>
<td>
<p>MDL flags</p>
</td>
<td>
<p>Incorrect MDL flags</p>
</td>
<td>
<p>The driver called <b>MmMapLockedPages</b> for an MDL with incorrect flags.  For example, the driver passed an MDL that is already mapped to a system address or that was not locked to <b>MmMapLockedPages</b>.  </p>
</td>
</tr>
<tr>
<td>
<p>0xB3  (Windows Vista and later operating  systems only)</p>
</td>
<td>
<p>MDL address</p>
</td>
<td>
<p>MDL flags</p>
</td>
<td>
<p>Missing MDL flags (at least one was expected)</p>
</td>
<td>
<p>The driver called <b>MmMapLockedPages</b> for an MDL with incorrect flags.  For example, the driver passed an MDL that is not locked to <b>MmMapLockedPages</b>.</p>
</td>
</tr>
<tr>
<td>
<p>0xB4  (Windows Vista and later operating systems only)</p>
</td>
<td>
<p>MDL address</p>
</td>
<td>
<p>MDL flags</p>
</td>
<td>
<p>Unexpected partial MDL flag</p>
</td>
<td>
<p>The driver called <b>MmUnlockPages</b> for a partial MDL.  A partial MDL is one that was created by <b>IoBuildPartialMdl</b>.</p>
</td>
</tr>
<tr>
<td>
<p>0xC0  (Windows Vista and later operating systems only)</p>
</td>
<td>
<p>Address of the IRP</p>
</td>
<td>
<p>Reserved</p>
</td>
<td>
<p>Reserved</p>
</td>
<td>
<p>The driver called <b>IoCallDriver</b> with interrupts disabled. </p>
</td>
</tr>
<tr>
<td>
<p>0xC1  (Windows Vista and later operating systems only)</p>
</td>
<td>
<p>Address of the driver dispatch routine</p>
</td>
<td>
<p>Reserved</p>
</td>
<td>
<p>Reserved</p>
</td>
<td>
<p>A driver dispatch routine was returned with interrupts disabled.</p>
</td>
</tr>
<tr>
<td>
<p>0xC2  (Windows Vista and later operating systems only)</p>
</td>
<td>
<p>Reserved</p>
</td>
<td>
<p>Reserved</p>
</td>
<td>
<p>Reserved</p>
</td>
<td>
<p>The driver called a Fast I/O dispatch routine after interrupts were disabled.</p>
</td>
</tr>
<tr>
<td>
<p>0xC3  (Windows Vista and later operating systems only)</p>
</td>
<td>
<p>Address of the driver Fast I/O dispatch routine</p>
</td>
<td>
<p>Reserved</p>
</td>
<td>
<p>Reserved</p>
</td>
<td>
<p>A driver Fast I/O dispatch routine was returned with interrupts disabled.</p>
</td>
</tr>
<tr>
<td>
<p>0xC5  (Windows Vista and later operating systems only)</p>
</td>
<td>
<p>Address of the driver dispatch routine</p>
</td>
<td>
<p>The current thread's APC disable count</p>
</td>
<td>
<p>The thread's APC disable count prior to calling the driver dispatch routine</p>
</td>
<td>
<p>A driver dispatch routine has changed the thread's APC disable count. </p>
<p>The APC disable count is decremented each time a driver calls <b>KeEnterCriticalRegion</b>, <b>FsRtlEnterFileSystem</b>, or acquires a mutex. </p>
<p>The APC disable count is incremented each time a driver calls <b>KeLeaveCriticalRegion</b>, <b>KeReleaseMutex</b>, or <b>FsRtlExitFileSystem</b>.</p>
<p>Because these calls should always be in pairs, the APC disable count should be zero whenever a thread is exited. A negative value indicates that a driver has disabled APC calls without re-enabling them. A positive value indicates that the reverse is true.</p>
</td>
</tr>
<tr>
<td>
<p>0xC6  (Windows Vista and later operating systems only)</p>
</td>
<td>
<p>Address of the driver Fast I/O dispatch routine</p>
</td>
<td>
<p>Current thread's APC disable count</p>
</td>
<td>
<p>The thread's APC disable count prior to calling the Fast I/O driver dispatch routine</p>
</td>
<td>
<p>A driver Fast I/O dispatch routine has changed the thread's APC disable count. </p>
<p>The APC disable count is decremented each time a driver calls <b>KeEnterCriticalRegion</b>, <b>FsRtlEnterFileSystem</b>, or acquires a mutex. </p>
<p>The APC disable count is incremented each time a driver calls <b>KeLeaveCriticalRegion</b>, <b>KeReleaseMutex</b>, or <b>FsRtlExitFileSystem</b>.</p>
<p>Because these calls should always be in pairs, the APC disable count should be zero whenever a thread is exited. A negative value indicates that a driver has disabled APC calls without re-enabling them. A positive value indicates that the reverse is true.</p>
</td>
</tr>
<tr>
<td>
<p>0xCA  (Windows Vista and later operating systems only)</p>
</td>
<td>
<p>Address of the lookaside list</p>
</td>
<td>
<p>Reserved</p>
</td>
<td>
<p>Reserved</p>
</td>
<td>
<p>The driver has attempted to re-initialize a lookaside list.</p>
</td>
</tr>
<tr>
<td>
<p>0xCB  (Windows Vista and later operating systems only)</p>
</td>
<td>
<p>Address of the lookaside list</p>
</td>
<td>
<p>Reserved</p>
</td>
<td>
<p>Reserved</p>
</td>
<td>
<p>The driver has attempted to delete an uninitialized lookaside list.</p>
</td>
</tr>
<tr>
<td>
<p>0xCC  (Windows Vista and later operating systems only)</p>
</td>
<td>
<p>Address of the lookaside list</p>
</td>
<td>
<p>Starting address of the pool allocation</p>
</td>
<td>
<p>Size of the pool allocation</p>
</td>
<td>
<p>The driver has attempted to free a pool allocation that contains an active lookaside list.</p>
</td>
</tr>
<tr>
<td>
<p>0xCD  (Windows Vista and later operating systems only)</p>
</td>
<td>
<p>Address of the lookaside list</p>
</td>
<td>
<p>Block size specified by the caller</p>
</td>
<td>
<p>Minimum supported block size</p>
</td>
<td>
<p>The driver has attempted to create a lookaside list with an allocation block size that is too small.</p>
</td>
</tr>
<tr>
<td>
<p>0xD0  (Windows Vista and later operating systems only)</p>
</td>
<td>
<p>Address of the ERESOURCE structure</p>
</td>
<td>
<p>Reserved</p>
</td>
<td>
<p>Reserved</p>
</td>
<td>
<p>The driver has attempted to re-initialize an ERESOURCE structure.</p>
</td>
</tr>
<tr>
<td>
<p>0xD1  (Windows Vista and later operating systems only)</p>
</td>
<td>
<p>Address of the ERESOURCE structure</p>
</td>
<td>
<p>Reserved</p>
</td>
<td>
<p>Reserved</p>
</td>
<td>
<p>The driver has attempted to delete an uninitialized ERESOURCE structure.</p>
</td>
</tr>
<tr>
<td>
<p>0xD2  (Windows Vista and later operating systems only)</p>
</td>
<td>
<p>Address of the ERESOURCE structure</p>
</td>
<td>
<p>Starting address of the pool allocation</p>
</td>
<td>
<p>Size of the pool allocation</p>
</td>
<td>
<p>The driver has attempted to free a pool allocation that contains an active ERESOURCE structure.</p>
</td>
</tr>
<tr>
<td>
<p>0xD5  (Windows Vista and later operating systems only)</p>
</td>
<td>
<p>Address of the IO_REMOVE_LOCK structure created by the checked build version of the driver</p>
</td>
<td>
<p>Current <b>IoReleaseRemoveLock</b> tag</p>
</td>
<td>
<p>Reserved</p>
</td>
<td>
<p>The current <b>IoReleaseRemoveLock</b> tag does not match the previous <b>IoAcquireRemoveLock</b> tag.  If the driver calling <b>IoReleaseRemoveLock</b> is not in a checked build, Parameter 2 is the address of the shadow IO_REMOVE_LOCK structure created by Driver Verifier on behalf of the driver. In this case, the address of the IO_REMOVE_LOCK structure used by the driver is not used at all, because Driver Verifier is replacing the lock address for all the remove lock APIs.   A bug check with this parameter occurs only when the <b>I/O Verification</b> option of Driver Verifier is active. </p>
</td>
</tr>
<tr>
<td>
<p>0xD6  (Windows Vista and later operating systems only)</p>
</td>
<td>
<p>Address of the IO_REMOVE_LOCK structure created by the checked build version of the driver</p>
</td>
<td>
<p>Tag that does not match previous <b>IoAcquireRemoveLock</b> tag</p>
</td>
<td>
<p>Previous <b>IoAcquireRemoveLock</b> tag</p>
</td>
<td>
<p>The current <b>IoReleaseRemoveLockAndWait</b> tag does not match the previous <b>IoAcquireRemoveLock</b> tag.  If the driver calling <b>IoReleaseRemoveLock</b> is not a checked build, Parameter 2 is the address of the shadow IO_REMOVE_LOCK structure created by Driver Verifier on behalf of the driver. In this case, the address of the IO_REMOVE_LOCK structure used by the driver is not used at all, because Driver Verifier is replacing the lock address for all the remove lock APIs.  A bug check with this parameter occurs only when the <b>I/O Verification</b> option of Driver Verifier is active. </p>
</td>
</tr>
<tr>
<td>
<p>0xD7  (Windows 7 operating systems and later only)</p>
</td>
<td>
<p>Address of the checked build Remove Lock structure that is used internally by Driver Verifier</p>
</td>
<td>
<p>Address of the Remove Lock structure that is specified by the driver</p>
</td>
<td>
<p>Reserved</p>
</td>
<td>
<p>A Remove Lock cannot be re-initialized, even after it calls <b>IoReleaseRemoveLockAndWait</b>, because other threads might still be using that lock (by calling <b>IoAcquireRemoveLock</b>). The driver should allocate the Remove Lock inside its device extension, and initialize it a single time. The lock will be deleted together with the device extension.</p>
</td>
</tr>
<tr>
<td>
<p>0xDA  (Windows Vista and later operating systems only)</p>
</td>
<td>
<p>Starting address of the driver</p>
</td>
<td>
<p>WMI callback address inside the driver</p>
</td>
<td>
<p>Reserved</p>
</td>
<td>
<p>An attempt was made to unload a driver that has not deregistered its WMI callback function.</p>
</td>
</tr>
<tr>
<td>
<p>0xDB  (Windows Vista and later operating systems only)</p>
</td>
<td>
<p>Address of the device object</p>
</td>
<td>
<p>Reserved</p>
</td>
<td>
<p>Reserved</p>
</td>
<td>
<p>An attempt was made to delete a device object that was not deregistered from WMI.</p>
</td>
</tr>
<tr>
<td>
<p>0xDC  (Windows Vista and later operating systems only)</p>
</td>
<td>
<p>Reserved</p>
</td>
<td>
<p>Reserved</p>
</td>
<td>
<p>Reserved</p>
</td>
<td>
<p>An invalid RegHandle value was specified as a parameter of the function <b>EtwUnregister</b>.</p>
</td>
</tr>
<tr>
<td>
<p>0xDD  (Windows Vista and later operating systems only)</p>
</td>
<td>
<p>Address of the call to <b>EtwRegister</b></p>
</td>
<td>
<p>Starting address of the unloading driver</p>
</td>
<td>
<p>For Windows 8Windows 8 and later versions, this parameter is the ETW RegHandle value.</p>
</td>
<td>
<p>An attempt was made to unload a driver without calling <b>EtwUnregister</b>.</p>
</td>
</tr>
<tr>
<td>
<p>0xDF  (Windows 7 operating systems and later only)</p>
</td>
<td>
<p>Synchronization object address </p>
</td>
<td></td>
<td></td>
<td>
<p>The synchronization object is in session address space. Synchronization objects are not allowed in session address space because they can be manipulated from another session or from system threads that have no session virtual address space.</p>
</td>
</tr>
<tr>
<td>
<p>0xE0  (Windows Vista and later operating systems only)</p>
</td>
<td>
<p>User-mode address that is used as a parameter</p>
</td>
<td>
<p>Size ,in bytes, of the address range that is used as a parameter</p>
</td>
<td>
<p>Reserved</p>
</td>
<td>
<p>A call was made to an operating system kernel function that specified a user-mode address as a parameter.</p>
</td>
</tr>
<tr>
<td>
<p>0xE1  (Windows Vista and later operating systems only)</p>
</td>
<td>
<p>Address of the synchronization object</p>
</td>
<td>
<p>Reserved</p>
</td>
<td>
<p>Reserved</p>
</td>
<td>
<p>A synchronization object was found to have an address that was either invalid or pageable.</p>
</td>
</tr>
<tr>
<td>
<p>0xE2  (Windows Vista and later operating systems only)</p>
</td>
<td>
<p>Address of the IRP</p>
</td>
<td>
<p>User-mode address present in the IRP </p>
</td>
<td>
<p>Reserved</p>
</td>
<td>
<p>An IRP with <b>Irp-&gt;RequestorMode</b> set to <b>KernelMode</b> was found to have a user-mode address as one of its members.</p>
</td>
</tr>
<tr>
<td>
<p>0xE3  (Windows Vista and later operating systems only)</p>
</td>
<td>
<p>Address of the call to the API</p>
</td>
<td>
<p>User-mode address used as a parameter in the API</p>
</td>
<td>
<p>Reserved</p>
</td>
<td>
<p>A driver has made a call to a kernel-mode <b>Zw<i>Xxx</i></b> routine with a user-mode address as a parameter.</p>
</td>
</tr>
<tr>
<td>
<p>0xE4  (Windows Vista and later operating systems only)</p>
</td>
<td>
<p>Address of the call to the API</p>
</td>
<td>
<p>Address of the malformed UNICODE_STRING structure</p>
</td>
<td>
<p>Reserved</p>
</td>
<td>
<p>A driver has made a call to a kernel-mode <b>Zw<i>Xxx</i></b> routine with a malformed UNICODE_STRING structure as a parameter.</p>
</td>
</tr>
<tr>
<td>
<p>0xE5  (Windows Vista and later operating systems only)</p>
</td>
<td>
<p>Current IRQL</p>
</td>
<td>
<p>Reserved</p>
</td>
<td>
<p>Reserved</p>
</td>
<td>
<p>A call was made to a Kernel API at the incorrect IRQL.</p>
</td>
</tr>
<tr>
<td>
<p>0xEA  (Windows Vista and later operating systems only)</p>
</td>
<td>
<p>Current IRQL</p>
</td>
<td>
<p>The thread's APC disable count</p>
</td>
<td>
<p>Address of the pushlock</p>
</td>
<td>
<p>A driver has attempted to acquire a pushlock while APCs are enabled.</p>
</td>
</tr>
<tr>
<td>
<p>0xEB  (Windows Vista and later operating systems only)</p>
</td>
<td>
<p>Current IRQL</p>
</td>
<td>
<p>The thread's APC disable count</p>
</td>
<td>
<p>Address of the pushlock</p>
</td>
<td>
<p>A driver has attempted to release a pushlock while APCs are enabled.</p>
</td>
</tr>
<tr>
<td>
<p>0xF0  (Windows Vista and later operating systems only)</p>
</td>
<td>
<p>Address of the destination buffer</p>
</td>
<td>
<p>Address of the source buffer</p>
</td>
<td>
<p>Number of bytes to copy</p>
</td>
<td>
<p>A driver called the memcpy function with overlapping source and destination buffers.</p>
</td>
</tr>
<tr>
<td>
<p>0xF5  (Windows Vista and later operating systems only)</p>
</td>
<td>
<p>Address of the <b>NULL</b> handle</p>
</td>
<td>
<p>Object type</p>
</td>
<td>
<p>Reserved</p>
</td>
<td>
<p>A driver passed a <b>NULL</b> handle to <b>ObReferenceObjectByHandle</b>.</p>
</td>
</tr>
<tr>
<td>
<p>0xF6 (Windows 7 operating systems and later)</p>
</td>
<td>
<p>Handle value being referenced</p>
</td>
<td>
<p>Address of the current process</p>
</td>
<td>
<p>Address inside the driver that performs the incorrect reference</p>
</td>
<td>
<p>A driver references a user-mode handle as kernel mode.</p>
</td>
</tr>
<tr>
<td>
<p>0xF7 (Windows 7 operating systems and later)</p>
</td>
<td>
<p>Handle value specified by the caller</p>
</td>
<td>
<p>Object type specified by the caller</p>
</td>
<td>
<p>AccessMode specified by the caller</p>
</td>
<td>
<p>A driver is attempting a user-mode reference for a kernel handle in the context of the system process.</p>
</td>
</tr>
<tr>
<td>
<p>0xFA (Windows 7 operating systems and later)</p>
</td>
<td>
<p>Completion routine address.</p>
</td>
<td>
<p>IRQL value before it calls the completion routine</p>
</td>
<td>
<p>Current IRQL value, after it calls the completion routine</p>
</td>
<td>
<p>The IRP completion routine returned at an IRQL that was different from the IRQL the routine was called at.</p>
</td>
</tr>
<tr>
<td>
<p>0xFB  (Windows 7 operating systems and later)</p>
</td>
<td>
<p>Completion routine address</p>
</td>
<td>
<p>Current thread's APC disable count</p>
</td>
<td>
<p>The thread's APC disable count before it calls the IRP completion routine</p>
</td>
<td>
<p>The thread's APC disable count was changed by the driver's IRP completion routine.</p>
<p>The APC disable count is decremented each time a driver calls <b>KeEnterCriticalRegion</b>, <b>FsRtlEnterFileSystem</b>, or acquires a mutex. </p>
<p>The APC disable count is incremented each time a driver calls <b>KeLeaveCriticalRegion</b>, <b>KeReleaseMutex</b>, or <b>FsRtlExitFileSystem</b>.</p>
<p>Because these calls should always be in pairs, the APC disable count should be zero whenever a thread is exited. A negative value indicates that a driver has disabled APC calls without re-enabling them. A positive value indicates that the reverse is true.</p>
</td>
</tr>
<tr>
<td>
<p>0x105</p>
<p>
        (Windows 7 operating systems and later)</p>
</td>
<td>
<p>Address of the IRP</p>
</td>
<td></td>
<td></td>
<td>
<p>The driver uses ExFreePool instead of IoFreeIrp to release the IRP.</p>
</td>
</tr>
<tr>
<td>
<p>0x10A</p>
<p>
        (Windows 7 operating systems and later)</p>
</td>
<td></td>
<td></td>
<td></td>
<td>
<p>The driver attempts to charge pool quota to the Idle process.</p>
</td>
</tr>
<tr>
<td>
<p>0x10B</p>
<p>
        (Windows 7 operating systems and later)</p>
</td>
<td></td>
<td></td>
<td></td>
<td>
<p>The driver attempts to charge pool quota from a DPC routine. This is incorrect because the current process context is undefined.</p>
</td>
</tr>
<tr>
<td>
<p>0x110</p>
<p>
        (Windows 7 operating systems and later)</p>
</td>
<td>
<p>Address of the Interrupt Service Routine</p>
</td>
<td>
<p>Address of the extended context that was saved before it executed the ISR</p>
</td>
<td>
<p>Address of the extended context was saved after it executed the ISR</p>
</td>
<td>
<p>The interrupt service routine (ISR) for the driver has corrupted the extended thread context.</p>
</td>
</tr>
<tr>
<td>
<p>0x115</p>
<p>
        (Windows 7 operating systems and later)</p>
</td>
<td>
<p>The address of the thread that is responsible for the shutdown, which might be deadlocked</p>
</td>
<td></td>
<td></td>
<td>
<p>Driver Verifier detected that the system has taken longer than 20 minutes and shutdown is not complete. </p>
</td>
</tr>
<tr>
<td>
<p>0x11A</p>
<p>
        (Windows 7 operating systems and later)</p>
</td>
<td>
<p>Current IRQL</p>
</td>
<td></td>
<td></td>
<td>
<p>The driver calls KeEnterCriticalRegion at IRQL &gt; APC_LEVEL.</p>
</td>
</tr>
<tr>
<td>
<p>0x11B</p>
<p>
        (Windows 7 operating systems and later)</p>
</td>
<td>
<p>Current IRQL</p>
</td>
<td></td>
<td></td>
<td>
<p>The driver calls KeLeaveCriticalRegion at IRQL &gt; APC_LEVEL.</p>
</td>
</tr>
<tr>
<td>
<p>0x120</p>
<p>
        (Windows 7 operating systems and later)</p>
</td>
<td>
<p>Address of the IRQL value</p>
</td>
<td>
<p>Address of the Object to wait on</p>
</td>
<td>
<p>Address of Timeout value</p>
</td>
<td>
<p>The thread waits at IRQL &gt; DISPATCH_LEVEL. Callers of KeWaitForSingleObject or KeWaitForMultipleObjects must run at IRQL &lt;= DISPATCH_LEVEL.</p>
</td>
</tr>
<tr>
<td>
<p>0x121</p>
<p>
        (Windows 7 operating systems and later)</p>
</td>
<td>
<p>Address of the IRQL value</p>
</td>
<td>
<p>Address of the Object to wait on</p>
</td>
<td>
<p>Address of Timeout value</p>
</td>
<td>
<p>The thread waits at IRQL equals DISPATCH_LEVEL and the Timeout is <b>NULL</b>. Callers of KeWaitForSingleObject or KeWaitForMultipleObjects can run at IRQL &lt;= DISPATCH_LEVEL. If a <b>NULL</b> pointer is supplied for Timeout, the calling thread remains in a wait state until the Object is signaled.</p>
</td>
</tr>
<tr>
<td>
<p>0x122</p>
<p>
        (Windows 7  operating systems and later)</p>
</td>
<td>
<p>Address of the IRQL value</p>
</td>
<td>
<p>Address of the Object to wait on</p>
</td>
<td>
<p>Address of the Timeout value </p>
</td>
<td>
<p>The thread waits at DISPATCH_LEVEL and Timeout value is not equal to zero (0). If the Timeout != 0, the callers of KeWaitForSingleObject or KeWaitForMultipleObjects must run at IRQL  &lt;= APC_LEVEL.</p>
</td>
</tr>
<tr>
<td>
<p>0x123</p>
<p>
        (Windows 7 operating systems and later)</p>
</td>
<td>
<p>Address of the Object to wait on</p>
</td>
<td></td>
<td></td>
<td>
<p>The caller of KeWaitForSingleObject or KeWaitForMultipleObjects specified the wait as <b>UserMode</b>, but the Object is on the kernel stack. </p>
</td>
</tr>
<tr>
<td>
<p>0x130</p>
<p>
        (Windows 7 operating systems and later)</p>
</td>
<td>
<p>Address of work item</p>
</td>
<td></td>
<td></td>
<td>
<p>The work item is in session address space. Work items are not allowed in session address space because they can be manipulated from another session or from system threads that have no session virtual address space.</p>
</td>
</tr>
<tr>
<td>
<p>0x131</p>
<p>
        (Windows 7 operating systems and later)</p>
</td>
<td>
<p>Address of work item</p>
</td>
<td></td>
<td></td>
<td>
<p>The work item is in pageable memory. Work items have to be in nonpageable memory because the kernel uses them at DISPATCH_LEVEL.</p>
</td>
</tr>
<tr>
<td>
<p>0x135</p>
</td>
<td>
<p>Address of IRP</p>
</td>
<td>
<p>Number of milliseconds allowed between the <b>IoCancelIrp</b> call and the completion for this IRP</p>
</td>
<td></td>
<td>
<p>The canceled IRP did not completed in the expected time The driver took longer than expected to complete the canceled IRP. </p>
</td>
</tr>
<tr>
<td>
<p>0x13A</p>
</td>
<td>
<p>Address of the pool block being freed</p>
</td>
<td>
<p>Incorrect value</p>
</td>
<td>
<p>Address of the incorrect value</p>
</td>
<td>
<p>The driver has called <b>ExFreePool</b> and Driver Verifier detects an error in one of the internal values that is used to track pool usage.</p>
</td>
</tr>
<tr>
<td>
<p>0x13B</p>
</td>
<td>
<p>Address of the pool block being freed</p>
</td>
<td>
<p>Address of the incorrect value</p>
</td>
<td>
<p>Address of a pointer to the incorrect memory page</p>
</td>
<td>
<p>The driver has called <b>ExFreePool</b> and Driver Verifier detects an error in one of the internal values that is used to track pool usage.</p>
</td>
</tr>
<tr>
<td>
<p>0x13C</p>
</td>
<td>
<p>Address of the pool block being freed</p>
</td>
<td>
<p>Incorrect value</p>
</td>
<td>
<p>Address of the incorrect value</p>
</td>
<td>
<p>The driver has called <b>ExFreePool</b> and Driver Verifier detects an error in one of the internal values that is used to track pool usage.</p>
</td>
</tr>
<tr>
<td>
<p>0x13D</p>
</td>
<td>
<p>Address of the pool block being freed</p>
</td>
<td>
<p>Address of the incorrect value</p>
</td>
<td>
<p>Correct value that was expected</p>
</td>
<td>
<p>The driver has called <b>ExFreePool</b> and Driver Verifier detects an error in one of the internal values that is used to track pool usage.</p>
</td>
</tr>
<tr>
<td>
<p>0x13E</p>
</td>
<td>
<p>Pool block address specified by the caller</p>
</td>
<td>
<p>Pool block address tracked by Driver Verifier</p>
</td>
<td>
<p>Pointer to the pool block address that is tracked by Driver Verifier</p>
</td>
<td>
<p>The pool block address specified by the caller of <b>ExFreePool</b> is different from the address tracked by Driver Verifier.</p>
</td>
</tr>
<tr>
<td>
<p>0x13F</p>
</td>
<td>
<p>Address of the pool block being freed</p>
</td>
<td>
<p>Number of bytes being freed</p>
</td>
<td>
<p>Pointer to the number of bytes tracked by Driver Verifier</p>
</td>
<td>
<p>The number of bytes of memory being freed in the call to <b>ExFreePool</b> is different from the number of bytes tracked by Driver Verifier.</p>
</td>
</tr>
<tr>
<td>
<p>0x1000 (Windows XP and later operating systems only)</p>
</td>
<td>
<p>Address of the resource</p>
</td>
<td>
<p>Reserved</p>
</td>
<td>
<p>Reserved</p>
</td>
<td>
<p><b>Self-deadlock:</b> The current thread has tried to recursively acquire a resource.  A bug check with this parameter occurs only when the <b>Deadlock Detection</b> option of Driver Verifier is active. </p>
</td>
</tr>
<tr>
<td>
<p>0x1001 (Windows XP and later operating systems only)</p>
</td>
<td>
<p>Address of the resource that was the final cause of the deadlock</p>
</td>
<td>
<p>Reserved</p>
</td>
<td>
<p>Reserved</p>
</td>
<td>
<p><b>Deadlock:</b> A lock hierarchy violation has been found.  A bug check with this parameter occurs only when the <b>Deadlock Detection</b> option of Driver Verifier is active. </p>
<p>(Use the <a href="_deadlock.htm"><b>!deadlock</b></a>  extension for further information.) </p>
</td>
</tr>
<tr>
<td>
<p>0x1002 (Windows XP and later operating systems only)</p>
</td>
<td>
<p>Address of the resource</p>
</td>
<td>
<p>Reserved</p>
</td>
<td>
<p>Reserved</p>
</td>
<td>
<p><b>Uninitialized resource:</b> A resource has been acquired without having been initialized first.  A bug check with this parameter occurs only when the <b>Deadlock Detection</b> option of Driver Verifier is active. </p>
</td>
</tr>
<tr>
<td>
<p>0x1003 (Windows XP and later operating systems only)</p>
</td>
<td>
<p>Address of the resource that is being released deadlocked</p>
</td>
<td>
<p>Address of the resource that should have been released first</p>
</td>
<td>
<p>Reserved</p>
</td>
<td>
<p><b>Unexpected release:</b> A resource has been released in an incorrect order.  A bug check with this parameter occurs only when the <b>Deadlock Detection</b> option of Driver Verifier is active. </p>
</td>
</tr>
<tr>
<td>
<p>0x1004 (Windows XP and later operating systems only)</p>
</td>
<td>
<p>Address of the resource</p>
</td>
<td>
<p>Address of the thread that acquired the resource</p>
</td>
<td>
<p>Address of the current thread</p>
</td>
<td>
<p><b>Unexpected thread:</b> The wrong thread releases a resource.  A bug check with this parameter occurs only when the <b>Deadlock Detection</b> option of Driver Verifier is active. </p>
</td>
</tr>
<tr>
<td>
<p>0x1005 (Windows XP and later operating systems only)</p>
</td>
<td>
<p>Address of the resource</p>
</td>
<td>
<p>Reserved</p>
</td>
<td>
<p>Reserved</p>
</td>
<td>
<p><b>Multiple initialization:</b> A resource is initialized more than one time.  A bug check with this parameter occurs only when the <b>Deadlock Detection</b> option of Driver Verifier is active. </p>
</td>
</tr>
<tr>
<td>
<p>0x1007 (Windows XP and later operating systems only)</p>
</td>
<td>
<p>Address of the resource</p>
</td>
<td>
<p>Reserved</p>
</td>
<td>
<p>Reserved</p>
</td>
<td>
<p><b>Unacquired resource:</b> A resource is released before it has been acquired.  A bug check with this parameter occurs only when the <b>Deadlock Detection</b> option of Driver Verifier is active. </p>
</td>
</tr>
<tr>
<td>
<p>0x1008</p>
<p>(Windows 7 operating systems and later)</p>
</td>
<td>
<p>Lock address</p>
</td>
<td>
<p>Driver Verifier internal data</p>
</td>
<td>
<p>Driver Verifier internal data</p>
</td>
<td>
<p>The driver tried to acquire a lock by using an API that is mismatched for this lock type.</p>
</td>
</tr>
<tr>
<td>
<p>0x1009</p>
<p>(Windows 7 operating systems and later)</p>
</td>
<td>
<p>Lock address</p>
</td>
<td>
<p>Driver Verifier internal data</p>
</td>
<td>
<p>Driver Verifier internal data</p>
</td>
<td>
<p>The driver tried to release a lock by using an API that is mismatched for this lock type.</p>
</td>
</tr>
<tr>
<td>
<p>0x100A</p>
<p>(Windows 7 operating systems and later)</p>
</td>
<td>
<p>Owner thread address</p>
</td>
<td>
<p>Driver Verifier internal data</p>
</td>
<td></td>
<td>
<p>The terminated thread owns the lock.</p>
</td>
</tr>
<tr>
<td>
<p>0x100B</p>
<p>(Windows 7 operating systems and later)</p>
</td>
<td>
<p>Lock address</p>
</td>
<td>
<p>Owner thread address</p>
</td>
<td>
<p>Driver Verifier internal address</p>
</td>
<td>
<p>The deleted lock is still owned by a thread.</p>
</td>
</tr>
<tr>
<td>
<p>0xA001</p>
<p>(Windows 8.1 operating systems and later)</p>
</td>
<td>
<p>A pointer to the <i>NetBufferList</i> object</p>
</td>
<td>
<p>A pointer to the virtual switch object (if NON-NULL)</p>
</td>
<td>
<p>Reserved (unused)</p>
</td>
<td>
<p>VM Switch: The <b>SourceHandle</b> for the caller-supplied <i>NetBufferList</i>  must be set. See the <i>AllocateNetBufferListForwardingContext</i> routine. </p>
</td>
</tr>
<tr>
<td>
<p>0xA002</p>
<p>(Windows 8.1 operating systems and later)</p>
</td>
<td>
<p>A pointer to the <i>NetBufferList</i> object</p>
</td>
<td>
<p>A pointer to the virtual switch object (if NON-NULL).</p>
</td>
<td>
<p>Reserved (unused)</p>
</td>
<td>
<p>VM Switch: The caller supplied NetBufferList's forwarding detail is not zero. See the <i>AllocateNetBufferListForwardingContext</i> routine.</p>
</td>
</tr>
<tr>
<td>
<p>0xA003</p>
<p>(Windows 8.1 operating systems and later)</p>
</td>
<td>
<p>A pointer to the <i>NetBufferList</i> object</p>
</td>
<td>
<p>A pointer to the virtual switch object (if NON-NULL).</p>
</td>
<td>
<p>Reserved (unused)</p>
</td>
<td>
<p>VM Switch: The caller supplied a <i>NetBufferList</i> with packet header or routing context that is NULL. See Packet Management Guidelines for the Extensible Switch Data Path.</p>
</td>
</tr>
<tr>
<td>
<p>0xA004</p>
<p>(Windows 8.1 operating systems and later)</p>
</td>
<td>
<p>ID of invalid port</p>
</td>
<td>
<p>NIC Index</p>
</td>
<td>
<p>A pointer to the virtual switch object (if NON-NULL). </p>
</td>
<td>
<p>VM Switch: The caller specified an invalid Port and NIC index combination.  See Hyper-V Extensible Switch Port and Network Adapter States.</p>
</td>
</tr>
<tr>
<td>
<p>0xA005</p>
<p>(Windows 8.1 operating systems and later)</p>
</td>
<td>
<p>A pointer to the <i>NetBufferList</i> object</p>
</td>
<td>
<p>A pointer to the Destination list.</p>
</td>
<td>
<p>A pointer to the virtual switch object (if NON-NULL). </p>
</td>
<td>
<p>VM Switch: The caller supplied an invalid destination. See  <i>AddNetBufferListDestination</i> and  <i>UpdateNetBufferListDestinations</i>. </p>
</td>
</tr>
<tr>
<td>
<p>0xA006</p>
<p>(Windows 8.1 operating systems and later)</p>
</td>
<td>
<p>A pointer to the <i>NetBufferList</i> object</p>
</td>
<td>
<p>A pointer to the virtual switch object (if NON-NULL).</p>
</td>
<td>
<p>Reserved (unused)</p>
</td>
<td>
<p>VM Switch: The caller supplied an invalid source NIC or Port object. See Hyper-V Extensible Switch Port and Network Adapter States.</p>
</td>
</tr>
<tr>
<td>
<p>0xA007</p>
<p>(Windows 8.1 operating systems and later)</p>
</td>
<td>
<p>A pointer to the <i>NetBufferList</i> object</p>
</td>
<td>
<p>A pointer to the virtual switch object (if NON-NULL).</p>
</td>
<td>
<p>Reserved (unused)</p>
</td>
<td>
<p>VM Switch: The caller supplied an invalid destination list. See <i>AddNetBufferListDestination</i>  and <i>UpdateNetBufferListDestinations</i>. </p>
</td>
</tr>
<tr>
<td>
<p>0xA008</p>
<p>(Windows 8.1 operating systems and later)</p>
</td>
<td>
<p>Parent NIC object</p>
</td>
<td>
<p>NIC index</p>
</td>
<td>
<p>A pointer to the virtual switch object (if NON-NULL). </p>
</td>
<td>
<p>VM Switch: Attempting to reference a NIC when not allowed.  See Hyper-V Extensible Switch Port and Network Adapter States.</p>
</td>
</tr>
<tr>
<td>
<p>0xA009</p>
<p>(Windows 8.1 operating systems and later)</p>
</td>
<td>
<p>Port being referenced</p>
</td>
<td>
<p>A pointer to the virtual switch object (if NON-NULL)</p>
</td>
<td>
<p>Reserved (unused)</p>
</td>
<td>
<p>VM Switch: Attempt to reference a port when not allowed. See Hyper-V Extensible Switch Port and Network Adapter States.</p>
</td>
</tr>
<tr>
<td>
<p>0xA00A</p>
<p>(Windows 8.1 operating systems and later)</p>
</td>
<td>
<p>A pointer to the <i>NetBufferList</i> object</p>
</td>
<td>
<p>ContextTypeInfo object</p>
</td>
<td>
<p>Reserved (unused)</p>
</td>
<td>
<p>VM Switch: Failure context is already set. See <i>SetNetBufferListSwitchContext</i>. </p>
</td>
</tr>
<tr>
<td>
<p>        0xA00B</p>
<p>(Windows 8.1 operating systems and later)</p>
</td>
<td>
<p>A pointer to the <i>NetBufferList</i> object</p>
</td>
<td>
<p>NDIS_SWITCH_REPORT_FILTERED_NBL_FLAGS_*</p>
</td>
<td>
<p>A pointer to the virtual switch object (if NON-NULL)</p>
</td>
<td>
<p>VM Switch: Invalid direction provided for dropped NetBufferList. See <i>ReportFilteredNetBufferLists</i>.</p>
</td>
</tr>
<tr>
<td>
<p>        0xA00C</p>
<p>(Windows 8.1 operating systems and later)</p>
</td>
<td>
<p>A pointer to the <i>NetBufferList</i> object</p>
</td>
<td>
<p>Send Flags value</p>
</td>
<td>
<p>A pointer to the virtual switch object (if NON-NULL)</p>
</td>
<td>
<p>VM Switch: NetBufferList chain has multiple source ports when NDIS_SEND_FLAGS_SWITCH_SINGLE_SOURCE flag is set. See Hyper-V Extensible Switch Send and Receive Flags. </p>
</td>
</tr>
<tr>
<td>
<p>        0xA00D</p>
<p>(Windows 8.1 operating systems and later)</p>
</td>
<td>
<p>A pointer to the <i>NetBufferList</i> object</p>
</td>
<td>
<p>A pointer to the virtual switch context</p>
</td>
<td>
<p>A pointer to the virtual switch object (if NON-NULL)</p>
</td>
<td>
<p>VM Switch: One or more NetBufferLists in chain have invalid destination when NDIS_RECEIVE_FLAGS_SWITCH_DESTINATION_GROUP flag is set.  See Hyper-V Extensible Switch Send and Receive Flags.</p>
</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>
<p>0x2000</p>
<p>(Windows 7 operating systems and later)</p>
</td>
<td>
<p>The first argument passed to the <b>StorPortInitialize</b> routine. This parameter is a pointer to the driver object that the operating system passed to the miniport driver in the first argument of the miniport driver's <i>DriverEntry</i> routine.

</p>
</td>
<td>
<p>The second argument passed to the <b>StorPortInitialize</b> routine. This parameter is a pointer to  context information that the operating system passed to the miniport driver in the second argument of the miniport driver's <i>DriverEntry</i> routine.</p>
</td>
<td>
<p>Reserved</p>
</td>
<td>
<p>The Storport miniport driver passed a bad argument (a <b>NULL</b> pointer) to the <b>StorPortInitialize</b> routine. </p>
<p></p>
</td>
</tr>
<tr>
<td>
<p>0x00020002</p>
<p>(Windows 8 operating systems and later)</p>
</td>
<td>
<p>Pointer to the string that describes the violated rule condition.</p>
</td>
<td>
<p>Optional pointer to the rule state variable(s).</p>
</td>
<td>
<p>Reserved</p>
</td>
<td>
<p>The driver violated the DDI compliance rule IrqlApcLte. The  rule specifies that the driver must call <b>ObGetObjectSecurity</b> and <b>ObReleaseObjectSecurity</b> only when IRQL &lt;= APC_LEVEL.</p>
</td>
</tr>
<tr>
<td>
<p>0x00020003</p>
<p>(Windows 8 operating systems and later)</p>
</td>
<td>
<p>Pointer to the string that describes the violated rule condition.</p>
</td>
<td>
<p>Optional pointer to the rule state variable(s).</p>
</td>
<td>
<p>Reserved</p>
</td>
<td>
<p>The driver violated the DDI compliance rule IrqlDispatch. The IrqlDispatch rule specifies that the driver must call certain routines only when IRQL = DISPATCH_LEVEL</p>
</td>
</tr>
<tr>
<td>
<p>0x00020004</p>
<p>(Windows 8 operating systems and later)</p>
</td>
<td>
<p>Pointer to the string that describes the violated rule condition.</p>
</td>
<td>
<p>Optional pointer to the rule state variable(s).</p>
</td>
<td>
<p>Reserved</p>
</td>
<td>
<p>The driver violated the DDI compliance rule IrqlExAllocatePool. The IrqlExAllocatePool rule specifies that the driver calls <b>ExAllocatePoolWithTag</b>  and <b>ExAllocatePoolWithTagPriority</b> only when at IRQL&lt;=DISPATCH_LEVEL.</p>
</td>
</tr>
<tr>
<td>
<p>0x00020005</p>
<p>(Windows 8 operating systems and later)</p>
</td>
<td>
<p>Pointer to the string that describes the violated rule condition.</p>
</td>
<td>
<p>Optional pointer to the rule state variable(s).</p>
</td>
<td>
<p>Reserved</p>
</td>
<td>
<p>The driver violated the DDI compliance rule IrqlExApcLte1. The IrqlExApcLte1 rule specifies that the driver calls ExAcquireFastMutex and ExTryToAcquireFastMutex only at IRQL &lt;= APC_LEVEL.</p>
</td>
</tr>
<tr>
<td>
<p>0x00020006</p>
<p>(Windows 8 operating systems and later)</p>
</td>
<td>
<p>Pointer to the string that describes the violated rule condition.</p>
</td>
<td>
<p>Optional pointer to the rule state variable(s).</p>
</td>
<td>
<p>Reserved</p>
</td>
<td>
<p>The driver violated the DDI compliance rule IrqlExApcLte2. The IrqlExApcLte2 rule specifies that the driver calls certain routines only when IRQL &lt;= APC_LEVEL.</p>
</td>
</tr>
<tr>
<td>
<p>0x00020007</p>
<p>(Windows 8 operating systems and later)</p>
</td>
<td>
<p>Pointer to the string that describes the violated rule condition.</p>
</td>
<td>
<p>Optional pointer to the rule state variable(s).</p>
</td>
<td>
<p>Reserved</p>
</td>
<td>
<p>The driver violated the DDI compliance rule IrqlExApcLte3. The IrqlExApcLte3 rule specifies that the driver must call certain executive support routines only when IRQL &lt;= APC_LEVEL.</p>
</td>
</tr>
<tr>
<td>
<p>0x00020008</p>
<p>(Windows 8 operating systems and later)</p>
</td>
<td>
<p>Pointer to the string that describes the violated rule condition.</p>
</td>
<td>
<p>Optional pointer to the rule state variable(s).</p>
</td>
<td>
<p>Reserved</p>
</td>
<td>
<p>The driver violated the DDI compliance rule IrqlExPassive. The IrqlExPassive
 rule specifies that the driver must call certain executive support routines only when IRQL = PASSIVE_LEVEL.</p>
</td>
</tr>
<tr>
<td>
<p>0x00020009</p>
<p>(Windows 8 operating systems and later)</p>
</td>
<td>
<p>Pointer to the string that describes the violated rule condition.</p>
</td>
<td>
<p>Optional pointer to the rule state variable(s).</p>
</td>
<td>
<p>Reserved</p>
</td>
<td>
<p>The driver violated the DDI compliance rule IrqlIoApcLte. The IrqlIoApcLte
 rule specifies that the driver must call certain I/O manager routines only when IRQL &lt;= APC_LEVEL.</p>
</td>
</tr>
<tr>
<td>
<p>0x0002000A</p>
<p>(Windows 8 operating systems and later)</p>
</td>
<td>
<p>Pointer to the string that describes the violated rule condition.</p>
</td>
<td>
<p>Optional pointer to the rule state variable(s).</p>
</td>
<td>
<p>Reserved</p>
</td>
<td>
<p>The driver violated the DDI compliance rule IrqlIoPassive1. The IrqlIoPassive1
 rule specifies that the driver must call certain I/O manager routines only when IRQL = PASSIVE_LEVEL.</p>
</td>
</tr>
<tr>
<td>
<p>0x0002000B</p>
<p>(Windows 8 operating systems and later)</p>
</td>
<td>
<p>Pointer to the string that describes the violated rule condition.</p>
</td>
<td>
<p>Optional pointer to the rule state variable(s).</p>
</td>
<td>
<p>Reserved</p>
</td>
<td>
<p>The driver violated the DDI compliance rule IrqlIoPassive2. The IrqlIoPassive2
 rule specifies that the driver must call certain I/O manager routines only when IRQL = PASSIVE_LEVEL.</p>
</td>
</tr>
<tr>
<td>
<p>0x0002000C</p>
<p>(Windows 8 operating systems and later)</p>
</td>
<td>
<p>Pointer to the string that describes the violated rule condition.</p>
</td>
<td>
<p>Optional pointer to the rule state variable(s).</p>
</td>
<td>
<p>Reserved</p>
</td>
<td>
<p>The driver violated the DDI compliance rule IrqlIoPassive3. The IrqlIoPassive3
 rule specifies that the driver must call certain I/O manager routines only when IRQL = PASSIVE_LEVEL.</p>
</td>
</tr>
<tr>
<td>
<p>0x0002000D</p>
<p>(Windows 8 operating systems and later)</p>
</td>
<td>
<p>Pointer to the string that describes the violated rule condition.</p>
</td>
<td>
<p>Optional pointer to the rule state variable(s).</p>
</td>
<td>
<p>Reserved</p>
</td>
<td>
<p>The driver violated the DDI compliance rule IrqlIoPassive4. The IrqlIoPassive4
 rule specifies that the driver must call certain I/O manager routines only when IRQL = PASSIVE_LEVEL.</p>
</td>
</tr>
<tr>
<td>
<p>0x0002000E</p>
<p>(Windows 8 operating systems and later)</p>
</td>
<td>
<p>Pointer to the string that describes the violated rule condition.</p>
</td>
<td>
<p>Optional pointer to the rule state variable(s).</p>
</td>
<td>
<p>Reserved</p>
</td>
<td>
<p>The driver violated the DDI compliance rule IrqlIoPassive5. The IrqlIoPassive5
 rule specifies that the driver must call certain I/O manager routines only when IRQL = PASSIVE_LEVEL.</p>
</td>
</tr>
<tr>
<td>
<p>0x0002000F</p>
<p>(Windows 8 operating systems and later)</p>
</td>
<td>
<p>Pointer to the string that describes the violated rule condition.</p>
</td>
<td>
<p>Optional pointer to the rule state variable(s).</p>
</td>
<td>
<p>Reserved</p>
</td>
<td>
<p>The driver violated the DDI compliance rule IrqlKeApcLte1. The IrqlKeApcLte1
 rule specifies that the driver must call certain kernel routines only when IRQL &lt;= APC_LEVEL.</p>
</td>
</tr>
<tr>
<td>
<p>0x00020010</p>
<p>(Windows 8 operating systems and later)</p>
</td>
<td>
<p>Pointer to the string that describes the violated rule condition.</p>
</td>
<td>
<p>Optional pointer to the rule state variable(s).</p>
</td>
<td>
<p>Reserved</p>
</td>
<td>
<p>The driver violated the DDI compliance rule IrqlKeApcLte2. The IrqlKeApcLte2
 rule specifies that the driver must call certain kernel routines only when IRQL &lt;= APC_LEVEL.</p>
</td>
</tr>
<tr>
<td>
<p>0x00020011</p>
<p>(Windows 8 operating systems and later)</p>
</td>
<td>
<p>Pointer to the string that describes the violated rule condition.</p>
</td>
<td>
<p>Optional pointer to the rule state variable(s).</p>
</td>
<td>
<p>Reserved</p>
</td>
<td>
<p>The driver violated the DDI compliance rule IrqlKeDispatchLte. The IrqlKeDispatchLte
 rule specifies that the driver must call certain kernel routines only when IRQL &lt;= DISPATCH_LEVEL.</p>
</td>
</tr>
<tr>
<td>
<p>0x00020015</p>
<p>(Windows 8 operating systems and later)</p>
</td>
<td>
<p>Pointer to the string that describes the violated rule condition.</p>
</td>
<td>
<p>Optional pointer to the rule state variable(s).</p>
</td>
<td>
<p>Reserved</p>
</td>
<td>
<p>The driver violated the DDI compliance rule IrqlKeReleaseSpinLock. The IrqlKeReleaseSpinLock
 rule specifies that the driver must call KeReleaseSpinLock  only when IRQL = DISPATCH_LEVEL.</p>
</td>
</tr>
<tr>
<td>
<p>0x00020016</p>
<p>(Windows 8 operating systems and later)</p>
</td>
<td>
<p>Pointer to the string that describes the violated rule condition.</p>
</td>
<td>
<p>Optional pointer to the rule state variable(s).</p>
</td>
<td>
<p>Reserved</p>
</td>
<td>
<p>The driver violated the DDI compliance rule IrqlKeSetEvent.  The IrqlKeSetEvent rule specifies that the <b>KeSetEvent</b> routine is only called at IRQL &lt;= DISPATCH_LEVEL when Wait is set to FALSE, and at IRQL &lt;= APC_LEVEL when Wait is set to TRUE.

</p>
</td>
</tr>
<tr>
<td>
<p>0x00020019</p>
<p>(Windows 8 operating systems and later)</p>
</td>
<td>
<p>Pointer to the string that describes the violated rule condition.</p>
</td>
<td>
<p>Optional pointer to the rule state variable(s).</p>
</td>
<td>
<p>Reserved</p>
</td>
<td>
<p>The driver violated the DDI compliance rule IrqlMmApcLte.  The IrqlMmApcLte rule specifies that the driver must call certain memory manager routines only when IRQL &lt;= APC_LEVEL.</p>
</td>
</tr>
<tr>
<td>
<p>0x0002001A</p>
<p>(Windows 8 operating systems and later)</p>
</td>
<td>
<p>Pointer to the string that describes the violated rule condition.</p>
</td>
<td>
<p>Optional pointer to the rule state variable(s).</p>
</td>
<td>
<p>Reserved</p>
</td>
<td>
<p>The driver violated the DDI compliance rule <b>IrqlMmDispatch</b>.  The <b>IrqlMmDispatch</b> rule specifies that the driver must call <b>MmFreeContiguousMemory</b> only when IRQL = DISPATCH_LEVEL.</p>
</td>
</tr>
<tr>
<td>
<p>0x0002001B</p>
<p>(Windows 8 operating systems and later)</p>
</td>
<td>
<p>Pointer to the string that describes the violated rule condition.</p>
</td>
<td>
<p>Optional pointer to the rule state variable(s).</p>
</td>
<td>
<p>Reserved</p>
</td>
<td>
<p>The driver violated the DDI compliance rule IrqlObPassive.  The IrqlObPassive  rule specifies that the driver must call <b>ObReferenceObjectByHandle</b>  only when IRQL = PASSIVE_LEVEL.</p>
</td>
</tr>
<tr>
<td>
<p>0x0002001C</p>
<p>(Windows 8 operating systems and later)</p>
</td>
<td>
<p>Pointer to the string that describes the violated rule condition.</p>
</td>
<td>
<p>Optional pointer to the rule state variable(s).</p>
</td>
<td>
<p>Reserved</p>
</td>
<td>
<p>The driver violated the DDI compliance rule IrqlPsPassive.  The IrqlPsPassive  rule specifies that the driver must call certain process and thread manager routines  only when IRQL = PASSIVE_LEVEL.</p>
</td>
</tr>
<tr>
<td>
<p>0x0002001D</p>
<p>(Windows 8.1 operating systems and later)</p>
</td>
<td>
<p>Pointer to the string that describes the violated rule condition.</p>
</td>
<td>
<p> Address of internal rule state (second argument to <b>!ruleinfo</b>).</p>
</td>
<td>
<p>Address of supplemental states (third argument to <b>!ruleinfo</b>).</p>
</td>
<td>
<p>The driver violated the DDI compliance rule <b>IrqlReturn</b>.</p>
</td>
</tr>
<tr>
<td>
<p>0x0002001E</p>
<p>(Windows 8 operating systems and later)</p>
</td>
<td>
<p>Pointer to the string that describes the violated rule condition.</p>
</td>
<td>
<p>Optional pointer to the rule state variable(s).</p>
</td>
<td>
<p>Reserved</p>
</td>
<td>
<p>The driver violated the DDI compliance rule IrqlRtlPassive.  The IrqlRtlPassive  rule specifies that the driver must call <b>RtlDeleteRegistryValue</b> only when IRQL = PASSIVE_LEVEL.</p>
</td>
</tr>
<tr>
<td>
<p>0x0002001F</p>
<p>(Windows 8 operating systems and later)</p>
</td>
<td>
<p>Pointer to the string that describes the violated rule condition.</p>
</td>
<td>
<p>Optional pointer to the rule state variable(s).</p>
</td>
<td>
<p>Reserved</p>
</td>
<td>
<p>The driver violated the DDI compliance rule IrqlZwPassive.  The IrqlZwPassive rule specifies that the driver must call <b>ZwClose</b> only when IRQL = PASSIVE_LEVEL.</p>
</td>
</tr>
<tr>
<td>
<p>0x00020022</p>
<p>(Windows 8.1 operating systems and later)</p>
</td>
<td>
<p>Pointer to the string that describes the violated rule condition.</p>
</td>
<td>
<p>Reserved (unused)</p>
</td>
<td>
<p>Reserved (unused)</p>
</td>
<td>
<p>The driver violated the DDI compliance rule <b>IrqlIoDispatch</b>.</p>
</td>
</tr>
<tr>
<td>
<p>0x00040003</p>
<p>(Windows 8.1 operating systems and later)</p>
</td>
<td>
<p>Pointer to the string that describes the violated rule condition.</p>
</td>
<td>
<p> Address of internal rule state (second argument to <b>!ruleinfo</b>).</p>
</td>
<td>
<p>Address of supplemental states (third argument to <b>!ruleinfo</b>).</p>
</td>
<td>
<p>The driver violated the DDI compliance rule <b>CriticalRegions</b>.</p>
</td>
</tr>
<tr>
<td>
<p>0x00040006</p>
<p>(Windows 8.1 operating systems and later)</p>
</td>
<td>
<p>Pointer to the string that describes the violated rule condition.</p>
</td>
<td>
<p> Address of internal rule state (second argument to <b>!ruleinfo</b>).</p>
</td>
<td>
<p>Address of supplemental states (third argument to <b>!ruleinfo</b>).</p>
</td>
<td>
<p>The driver violated the DDI compliance rule <b>QueuedSpinLock</b>.</p>
</td>
</tr>
<tr>
<td>
<p>0x00040007</p>
<p>(Windows 8.1 operating systems and later)</p>
</td>
<td>
<p>Pointer to the string that describes the violated rule condition.</p>
</td>
<td>
<p> Address of internal rule state (second argument to <b>!ruleinfo</b>).</p>
</td>
<td>
<p>Address of supplemental states (third argument to <b>!ruleinfo</b>).</p>
</td>
<td>
<p>The driver violated the DDI compliance rule <b>QueuedSpinLockRelease</b>.</p>
</td>
</tr>
<tr>
<td>
<p>0x00040009</p>
<p>(Windows 8.1 operating systems and later)</p>
</td>
<td>
<p>Pointer to the string that describes the violated rule condition.</p>
</td>
<td>
<p> Address of internal rule state (second argument to <b>!ruleinfo</b>).</p>
</td>
<td>
<p>Address of supplemental states (third argument to <b>!ruleinfo</b>).</p>
</td>
<td>
<p>The driver violated the DDI compliance rule <b>SpinLock</b>.</p>
</td>
</tr>
<tr>
<td>
<p>0x0004000B</p>
<p>(Windows 8.1 operating systems and later)</p>
</td>
<td>
<p>Pointer to the string that describes the violated rule condition.</p>
</td>
<td>
<p> Address of internal rule state (second argument to <b>!ruleinfo</b>).</p>
</td>
<td>
<p>Address of supplemental states (third argument to <b>!ruleinfo</b>).</p>
</td>
<td>
<p>The driver violated the DDI compliance rule <b>SpinlockRelease</b>.</p>
</td>
</tr>
<tr>
<td>
<p>0x0004000E</p>
<p>(Windows 8.1 operating systems and later)</p>
</td>
<td>
<p>Pointer to the string that describes the violated rule condition.</p>
</td>
<td>
<p>Address of internal rule state (second argument to <b>!ruleinfo</b>).</p>
</td>
<td>
<p>Address of supplemental states (third argument to <b>!ruleinfo</b>).</p>
</td>
<td>
<p>The driver violated the DDI compliance rule <b>GuardedRegions</b>.</p>
</td>
</tr>
<tr>
<td>
<p>0x0004100B</p>
<p>(Windows 8.1 operating systems and later)</p>
</td>
<td>
<p>Pointer to the string that describes the violated rule condition.</p>
</td>
<td>
<p>Reserved</p>
</td>
<td>
<p>Reserved</p>
</td>
<td>
<p>The driver violated the DDI compliance rule <b>RequestedPowerIrp</b>.</p>
</td>
</tr>
<tr>
<td>
<p>0x0004100F</p>
<p>(Windows 8.1 operating systems and later)</p>
</td>
<td>
<p>Pointer to the string that describes the violated rule condition.</p>
</td>
<td>
<p> Address of internal rule state (second argument to <b>!ruleinfo</b>).</p>
</td>
<td>
<p>Address of supplemental states (third argument to <b>!ruleinfo</b>).</p>
</td>
<td>
<p>The driver violated the DDI compliance rule <b>IoSetCompletionExCompleteIrp</b>.</p>
</td>
</tr>
<tr>
<td>
<p>0x00043006</p>
<p>(Windows 8.1 operating systems and later)</p>
</td>
<td>
<p>Pointer to the string that describes the violated rule condition.</p>
</td>
<td>
<p>Reserved</p>
</td>
<td>
<p>Reserved</p>
</td>
<td>
<p>The driver violated the DDI compliance rule <b>PnpRemove</b>.</p>
</td>
</tr>
<tr>
<td>
<p>0x00091001</p>
<p>(Windows 8.1 operating systems and later)</p>
</td>
<td>
<p>Pointer to the string that describes the violated rule condition.</p>
</td>
<td>
<p> Address of internal rule state (second argument to <b>!ruleinfo</b>).</p>
</td>
<td>
<p>Address of supplemental states (third argument to <b>!ruleinfo</b>).</p>
</td>
<td>
<p>The driver violated the DDI compliance rule <b>NdisOidComplete</b>.</p>
</td>
</tr>
<tr>
<td>
<p>0x00091002</p>
<p>(Windows 8.1 operating systems and later)</p>
</td>
<td>
<p>Pointer to the string that describes the violated rule condition.</p>
</td>
<td>
<p> Address of internal rule state (second argument to <b>!ruleinfo</b>).</p>
</td>
<td>
<p>Address of supplemental states (third argument to <b>!ruleinfo</b>).</p>
</td>
<td>
<p>The driver violated the DDI compliance rule <b>NdisOidDoubleComplete</b>.</p>
</td>
</tr>
<tr>
<td>
<p>0x0009100E</p>
<p>(Windows 8.1 operating systems and later)</p>
</td>
<td>
<p>Pointer to the string that describes the violated rule condition.</p>
</td>
<td>
<p> Address of internal rule state (second argument to <b>!ruleinfo</b>).</p>
</td>
<td>
<p>Address of supplemental states (third argument to <b>!ruleinfo</b>).</p>
</td>
<td>
<p>The driver violated the DDI compliance rule <b>NdisOidDoubleRequest</b>.</p>
</td>
</tr>
<tr>
<td>
<p> 0x00092003</p>
<p>(Windows 8.1 operating systems and later)</p>
</td>
<td>
<p>Pointer to the string that describes the violated rule condition.</p>
</td>
<td>
<p> Address of internal rule state (second argument to <b>!ruleinfo</b>).</p>
</td>
<td>
<p>Address of supplemental states (third argument to <b>!ruleinfo</b>).</p>
</td>
<td>
<p>The driver violated the NDIS/WIFI verification rule <b>NdisTimedOidComplete</b>.</p>
</td>
</tr>
<tr>
<td>
<p> 0x0009200D</p>
<p>(Windows 8.1 operating systems and later)</p>
</td>
<td>
<p>Pointer to the string that describes the violated rule condition.</p>
</td>
<td>
<p> Address of internal rule state (second argument to <b>!ruleinfo</b>).</p>
</td>
<td>
<p>Address of supplemental states (third argument to <b>!ruleinfo</b>).</p>
</td>
<td>
<p>The driver violated the NDIS/WIFI verification rule <b>NdisTimedDataSend</b>.</p>
</td>
</tr>
<tr>
<td>
<p> 0x0009200F</p>
<p>(Windows 8.1 operating systems and later)</p>
</td>
<td>
<p>Pointer to the string that describes the violated rule condition.</p>
</td>
<td>
<p> Address of internal rule state (second argument to <b>!ruleinfo</b>).</p>
</td>
<td>
<p>Address of supplemental states (third argument to <b>!ruleinfo</b>).</p>
</td>
<td>
<p>The driver violated the NDIS/WIFI verification rule <b>NdisTimedDataHang</b>.</p>
</td>
</tr>
<tr>
<td>
<p> 0x00093004</p>
<p>(Windows 8.1 operating systems and later)</p>
</td>
<td>
<p>Pointer to the string that describes the violated rule condition.</p>
</td>
<td>
<p> Address of internal rule state (second argument to <b>!ruleinfo</b>).</p>
</td>
<td>
<p>Address of supplemental states (third argument to <b>!ruleinfo</b>).</p>
</td>
<td>
<p>The driver violated the NDIS/WIFI verification rule <b>WlanAssociation</b>.</p>
</td>
</tr>
<tr>
<td>
<p>0x00093005</p>
<p>(Windows 8.1 operating systems and later)</p>
</td>
<td>
<p>Pointer to the string that describes the violated rule condition.</p>
</td>
<td>
<p> Address of internal rule state (second argument to <b>!ruleinfo</b>).</p>
</td>
<td>
<p>Address of supplemental states (third argument to <b>!ruleinfo</b>).</p>
</td>
<td>
<p>The driver violated the NDIS/WIFI verification rule <b>WlanConnectionRoaming</b>.</p>
</td>
</tr>
<tr>
<td>
<p>0x00093006</p>
<p>(Windows 8.1 operating systems and later)</p>
</td>
<td>
<p>Pointer to the string that describes the violated rule condition.</p>
</td>
<td>
<p> Address of internal rule state (second argument to <b>!ruleinfo</b>).</p>
</td>
<td>
<p>Address of supplemental states (third argument to <b>!ruleinfo</b>).</p>
</td>
<td>
<p>The driver violated the NDIS/WIFI verification rule <b>WlanDisassociation</b>.</p>
</td>
</tr>
<tr>
<td>
<p>0x00094007</p>
<p>(Windows 8.1 operating systems and later)</p>
</td>
<td>
<p>Pointer to the string that describes the violated rule condition.</p>
</td>
<td>
<p> Address of internal rule state (second argument to <b>!ruleinfo</b>).</p>
</td>
<td>
<p>Address of supplemental states (third argument to <b>!ruleinfo</b>).</p>
</td>
<td>
<p>The driver violated the NDIS/WIFI verification rule <b>WlanTimedAssociation</b>.</p>
</td>
</tr>
<tr>
<td>
<p>0x00094008</p>
<p>(Windows 8.1 operating systems and later)</p>
</td>
<td>
<p>Pointer to the string that describes the violated rule condition.</p>
</td>
<td>
<p> Address of internal rule state (second argument to <b>!ruleinfo</b>).</p>
</td>
<td>
<p>Address of supplemental states (third argument to <b>!ruleinfo</b>).</p>
</td>
<td>
<p>The driver violated the NDIS/WIFI verification rule <b>WlanTimedConnectionRoaming</b>.</p>
</td>
</tr>
<tr>
<td>
<p>0x00094009</p>
<p>(Windows 8.1 operating systems and later)</p>
</td>
<td>
<p>Pointer to the string that describes the violated rule condition.</p>
</td>
<td>
<p> Address of internal rule state (second argument to <b>!ruleinfo</b>).</p>
</td>
<td>
<p>Address of supplemental states (third argument to <b>!ruleinfo</b>).</p>
</td>
<td>
<p>The driver violated the NDIS/WIFI verification rule <b>WlanTimedConnectRequest</b>.</p>
</td>
</tr>
<tr>
<td>
<p> 0x0009400B</p>
<p>(Windows 8.1 operating systems and later)</p>
</td>
<td>
<p>Pointer to the string that describes the violated rule condition.</p>
</td>
<td>
<p> Address of internal rule state (second argument to <b>!ruleinfo</b>).</p>
</td>
<td>
<p>Address of supplemental states (third argument to <b>!ruleinfo</b>).</p>
</td>
<td>
<p>The driver violated the NDIS/WIFI verification rule <b>WlanTimedLinkQuality</b>.</p>
</td>
</tr>
<tr>
<td>
<p>0x0009400C</p>
<p>(Windows 8.1 operating systems and later)</p>
</td>
<td>
<p>Pointer to the string that describes the violated rule condition.</p>
</td>
<td>
<p> Address of internal rule state (second argument to <b>!ruleinfo</b>).</p>
</td>
<td>
<p>Address of supplemental states (third argument to <b>!ruleinfo</b>).</p>
</td>
<td>
<p>The driver violated the NDIS/WIFI verification rule <b>WlanTimedScan</b>.</p>
</td>
</tr>
</table>
<p> </p>
<h2>Cause</h2>
<p>See the description of each code in the Parameters section for a description of the cause. Further information can be obtained by using the <a href="_analyze.htm"><b>!analyze -v </b></a> extension.</p>
<h2>Resolution</h2>
<p>This bug check can only occur when Driver Verifier has been instructed to monitor one or more drivers. If you did not intend to use Driver Verifier, you should deactivate it. You might also consider removing the driver that caused this problem.</p>
<p>If you are the driver writer, use the information obtained through this bug check to fix the bugs in your code.</p>
<p>For full details on Driver Verifier,  see the Driver Verifier section of the Windows Driver Kit (WDK).           </p>
<h2>Remarks</h2>
<p>The _POOL_TYPE codes are enumerated in Ntddk.h. In particular, <b>0</b> (zero) indicates nonpaged pool and <b>1</b> (one) indicates paged pool.</p>
<p><i>(Windows 8 and later versions of Windows)</i>     If DDI compliance checking  causes a bug check, run Static Driver Verifier on the driver source code and specify the DDI compliance rule (identified by the parameter 1 value) that caused the bug check.  Static Driver Verifier can help you locate the cause of the problem in your source code.</p>
<h2><a id="see_also"></a>See also</h2>
<dl>
<dt><a href="handling_a_bug_check_when_driver_verifier_is_enabled.htm">Handling a Bug Check When Driver Verifier is Enabled</a></dt>
</dl>
<p> </p>
<p> </p>
</div>
<p style="text-align:left;font-family:Arial,sanserif;font-size:100%;color:black">
&#x00a9;&#x00a0;2016 Microsoft. All rights reserved.</p>

</body>
</html>
