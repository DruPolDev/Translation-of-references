<html xmlns:msxsl="urn:schemas-microsoft-com:xslt" xmlns:mssdk="winsdk" xmlns:script="urn:script" xmlns:build="urn:build" xmlns:MSHelp="http://msdn.microsoft.com/mshelp">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
<meta name="Description" content="Annotated x64 Disassembly"/>
<meta name="MSHAttr" content="PreferredSiteName:MSDN"/>
<meta name="MSHAttr" content="PreferredLib:/library/windows/hardware"/>
<title>Annotated x64 Disassembly</title>

<meta name="MS-HAID" content="t09_arch_x86_76f4de05-24cc-4c2a-af64-a7361e8fc2ce.xml"/>


<link rel="STYLESHEET" type="text/css" HREF="../common/backsdk4.css"/>


</head>
<body>

<div id="mainSection">
<div class="clsServerSDKContent">
<h1><a id="debugger.annotated_x64_disassembly"></a>Annotated x64 Disassembly</h1>
</div>
<h2><a id="ddk_annotated_x64_disassembly_dbg"></a><a id="DDK_ANNOTATED_X64_DISASSEMBLY_DBG"></a></h2>
<p></p>
<p>The following very simple function illustrates the x64 calling convention.</p>
<pre class="syntax" xml:space="preserve"><code>int Simple(int i, int j)
{
    return i*5 + j + 3;
}</code></pre>
<p>This compiles to code like this:</p>
<pre class="syntax" xml:space="preserve"><code>01001080 lea     eax,[rdx+rcx*4]        ; eax = rdx+rcx*4
01001083 lea     eax,[rcx+rax+0x3]      ; eax = rcx+rax+3
01001087 ret</code></pre>
<p>The <i>i</i> and <i>j</i> parameters are passed in the <b>ecx</b> and <b>edx</b> registers, respectively.  Since there are only two parameters, the routine does not use the stack at all.</p>
<p>The particular code generated exploits three tricks, one of which is specific to the x64:</p>
<ol>
<li>
<p>The <b>lea</b> operation can be used to perform a series of simple arithmetic operations as a single operation.  The first instruction stores <i>j+i</i>*4 in <b>eax</b>, and the second instruction adds <i>i</i>+3 to the result, for a total of <i>j</i>+<i>i</i>*5+3.</p>
</li>
<li>
<p>Many operations, such as addition and multiplication, can be done with extra precision, and then truncated to the correct precision.  In this instance, the code uses 64-bit addition and multiplication.  We can safely truncate the result to 32 bits.</p>
</li>
<li>
<p>On the x64, any operation that outputs to a 32-bit register automatically zero-extends the result.  In this case, outputting to <b>eax</b> has the effect of truncating the result to 32 bits.</p>
</li>
</ol>
<p>Return values are passed in the <b>rax</b> register.  In this case, the result is already in the <b>rax</b> register, so the function returns.</p>
<p>Next we consider a more complicated function to demonstrate typical x64 disassembly:</p>
<pre class="syntax" xml:space="preserve"><code>HRESULT Meaningless(IDispatch *pdisp, DISPID dispid, BOOL fUnique, LPCWSTR pszExe)
{
    IQueryAssociations *pqa;
    HRESULT hr = AssocCreate(CLSID_QueryAssociations, IID_IQueryAssociations, (void**)&amp;pqa);
    if (SUCCEEDED(hr)) {
        hr = pqa-&gt;Init(ASSOCF_INIT_BYEXENAME, pszExe, NULL, NULL);
        if (SUCCEEDED(hr)) {
            WCHAR wszName[MAX_PATH];
            DWORD cchName = MAX_PATH;
            hr = pqa-&gt;GetString(0, ASSOCSTR_FRIENDLYAPPNAME, NULL, wszName, &amp;cchName);
            if (SUCCEEDED(hr)) {
                VARIANTARG rgvarg[2] = { 0 };
                V_VT(&amp;rgvarg[0]) = VT_BSTR;
                V_BSTR(&amp;rgvarg[0]) = SysAllocString(wszName);
                if (V_BSTR(&amp;rgvarg[0])) {
                    DISPPARAMS dp;
                    LONG lUnique = InterlockedIncrement(&amp;lCounter);
                    V_VT(&amp;rgvarg[1]) = VT_I4;
                    V_I4(&amp;rgvarg[1]) = fUnique ? lUnique : 0;
                    dp.rgvarg = rgvarg;
                    dp.cArgs = 2;
                    dp.rgdispidNamedArgs = NULL;
                    dp.cNamedArgs = 0;
                    hr = pdisp-&gt;Invoke(dispid, IID_NULL, 0, DISPATCH_METHOD, &amp;dp, NULL, NULL, NULL);
                    VariantClear(&amp;rgvarg[0]);
                    VariantClear(&amp;rgvarg[1]);
                } else {
                    hr = E_OUTOFMEMORY;
                }
            }
        }
        pqa-&gt;Release();
    }
    return hr;
}</code></pre>
<p>We'll go through this function and the equivalent assembly line by line.</p>
<p>When entered, the function's parameters are stored as follows:</p>
<ul>
<li>
<p><b>rcx</b> = <i>pdisp</i>.</p>
</li>
<li>
<p><b>rdx</b> = <i>dispid</i>.</p>
</li>
<li>
<p><b>r8</b> = <i>fUnique</i>.</p>
</li>
<li>
<p><b>r9</b> = <i>pszExe</i>.</p>
</li>
</ul>
<p>Recall that the first four parameters are passed in registers. Since this function has only four registers, none are passed on the stack.</p>
<p>The assembly begins as follows:</p>
<pre class="syntax" xml:space="preserve"><code>Meaningless:
010010e0 push    rbx                    ; save
010010e1 push    rsi                    ; save
010010e2 push    rdi                    ; save
010010e3 push    r12d                   ; save
010010e5 push    r13d                   ; save
010010e7 push    r14d                   ; save
010010e9 push    r15d                   ; save
010010eb sub     rsp,0x2c0              ; reserve stack
010010f2 mov     rbx,r9                 ; rbx = pszExe
010010f5 mov     r12d,r8d               ; r12 = fUnique (zero-extend)
010010f8 mov     r13d,edx               ; r13 = dispid  (zero-extend)
010010fb mov     rsi,rcx                ; rsi = pdisp</code></pre>
<p>The function begins by saving nonvolatile registers, and then reserving stack space for local variables.  It then saves parameters in nonvolatile registers.  Note that the destination of the middle two <b>mov</b> instructions is a 32-bit register, so they are implicitly zero-extended to 64 bits.</p>
<pre class="syntax" xml:space="preserve"><code>    IQueryAssociations *pqa;
    HRESULT hr = AssocCreate(CLSID_QueryAssociations, IID_IQueryAssociations, (void**)&amp;pqa);</code></pre>
<p>The first parameter to <b>AssocCreate</b> is a 128-bit CLSID passed by value. Since this doesn't fit in a 64-bit register, the CLSID is copied to the stack, and a pointer to the stack location is passed instead.</p>
<pre class="syntax" xml:space="preserve"><code>010010fe movdqu  xmm0,oword ptr [CLSID_QueryAssociations (01001060)]
01001106 movdqu  oword ptr [rsp+0x60],xmm0  ; temp buffer for first parameter
0100110c lea     r8,[rsp+0x58]          ; arg3 = &amp;pqa
01001111 lea rdx,[IID_IQueryAssociations (01001070)] ; arg2 = &amp;IID_IQueryAssociations
01001118 lea     rcx,[rsp+0x60]         ; arg1 = &amp;temporary
0100111d call qword ptr [_imp_AssocCreate (01001028)] ; call</code></pre>
<p>The <b>movdqu</b> instruction transfers 128-bits values to and from <b>xmm</b><i>n</i> registers. In this instance, the assembly code uses it to copy the CLSID to the stack.  The pointer to the CLSID is passed in <b>r8</b>.  The other two arguments are passed in <b>rcx</b> and <b>rdx</b>.</p>
<pre class="syntax" xml:space="preserve"><code>    if (SUCCEEDED(hr)) {

01001123 test    eax,eax
01001125 jl      ReturnEAX (01001281)</code></pre>
<p>The code checks to see if the return value is a success.</p>
<pre class="syntax" xml:space="preserve"><code>        hr = pqa-&gt;Init(ASSOCF_INIT_BYEXENAME, pszExe, NULL, NULL);

0100112b mov     rcx,[rsp+0x58]         ; arg1 = pqa
01001130 mov     rax,[rcx]              ; rax = pqa.vtbl
01001133 xor     r14d,r14d              ; r14 = 0
01001136 mov     [rsp+0x20],r14         ; arg5 = 0
0100113b xor     r9d,r9d                ; arg4 = 0
0100113e mov     r8,rbx                 ; arg3 = pszExe
01001141 mov     r15d,0x2               ; r15 = 2 (for later)
01001147 mov     edx,r15d               ; arg2 = 2 (ASSOCF_INIT_BY_EXENAME)
0100114a call    qword ptr [rax+0x18]   ; call Init method</code></pre>
<p>This is an indirect function call using a C++ vtable. The <b>this</b> pointer is passed in <b>rcx</b> as the first parameter.  The first three parameters are passed in registers, while the final parameter is passed on the stack.  The function reserves 16 bytes for the parameters passed in registers, so the fifth parameter begins at <b>rsp</b>+0x20.  </p>
<pre class="syntax" xml:space="preserve"><code>        if (SUCCEEDED(hr)) {

0100114d mov     ebx,eax                ; ebx = hr
0100114f test    ebx,ebx                ; FAILED?
01001151 jl      ReleasePQA (01001274)  ; jump if so</code></pre>
<p>The assembly-language code saves the result in <b>ebx</b>, and checks to see if it's a success code.</p>
<pre class="syntax" xml:space="preserve"><code>            WCHAR wszName[MAX_PATH];
            DWORD cchName = MAX_PATH;
            hr = pqa-&gt;GetString(0, ASSOCSTR_FRIENDLYAPPNAME, NULL, wszName, &amp;cchName);
            if (SUCCEEDED(hr)) {

01001157 mov     dword ptr [rsp+0x50],0x104 ; cchName = MAX_PATH
0100115f mov     rcx,[rsp+0x58]         ; arg1 = pqa
01001164 mov     rax,[rcx]              ; rax = pqa.vtbl
01001167 lea     rdx,[rsp+0x50]         ; rdx = &amp;cchName
0100116c mov     [rsp+0x28],rdx         ; arg6 = cchName
01001171 lea     rdx,[rsp+0xb0]         ; rdx = &amp;wszName[0]
01001179 mov     [rsp+0x20],rdx         ; arg5 = &amp;wszName[0]
0100117e xor     r9d,r9d                ; arg4 = 0
01001181 mov     r8d,0x4                ; arg3 = 4 (ASSOCSTR_FRIENDLYNAME)
01001187 xor     edx,edx                ; arg2 = 0
01001189 call    qword ptr [rax+0x20]   ; call GetString method
0100118c mov     ebx,eax                ; ebx = hr
0100118e test    ebx,ebx                ; FAILED?
01001190 jl      ReleasePQA (01001274)  ; jump if so</code></pre>
<p>Once again, we set up the parameters and call a function, then test the return value for success.</p>
<pre class="syntax" xml:space="preserve"><code>                VARIANTARG rgvarg[2] = { 0 };

01001196 lea     rdi,[rsp+0x82]         ; rdi = &amp;rgvarg
0100119e xor     eax,eax                ; rax = 0
010011a0 mov     ecx,0x2e               ; rcx = sizeof(rgvarg)
010011a5 rep     stosb                  ; Zero it out</code></pre>
<p>The idiomatic method for zeroing out a buffer on x64 is the same as x86.</p>
<pre class="syntax" xml:space="preserve"><code>                V_VT(&amp;rgvarg[0]) = VT_BSTR;
                V_BSTR(&amp;rgvarg[0]) = SysAllocString(wszName);
                if (V_BSTR(&amp;rgvarg[0])) {

010011a7 mov     word ptr [rsp+0x80],0x8 ; V_VT(&amp;rgvarg[0]) = VT_BSTR
010011b1 lea     rcx,[rsp+0xb0]         ; arg1 = &amp;wszName[0]
010011b9 call    qword ptr [_imp_SysAllocString (01001010)] ; call
010011bf mov     [rsp+0x88],rax         ; V_BSTR(&amp;rgvarg[0]) = result
010011c7 test    rax,rax                ; anything allocated?
010011ca je      OutOfMemory (0100126f) ; jump if failed

                    DISPPARAMS dp;
                    LONG lUnique = InterlockedIncrement(&amp;lCounter);

010011d0 lea     rax,[lCounter (01002000)]
010011d7 mov     ecx,0x1
010011dc lock    xadd [rax],ecx             ; interlocked exchange and add
010011e0 add     ecx,0x1</code></pre>
<p><b>InterlockedIncrement</b> compiles directly to machine code.  The <b>lock xadd</b> instruction performs an atomic exchange and add.  The final result is stored in <b>ecx</b>.</p>
<pre class="syntax" xml:space="preserve"><code>                    V_VT(&amp;rgvarg[1]) = VT_I4;
                    V_I4(&amp;rgvarg[1]) = fUnique ? lUnique : 0;

010011e3 mov     word ptr [rsp+0x98],0x3    ; V_VT(&amp;rgvarg[1]) = VT_I4;
010011ed mov     eax,r14d                   ; rax = 0 (r14d is still zero)
010011f0 test    r12d,r12d                  ; fUnique set?
010011f3 cmovne  eax,ecx                    ; if so, then set rax=lCounter
010011f6 mov     [rsp+0xa0],eax             ; V_I4(&amp;rgvarg[1]) = ...</code></pre>
<p>Since x64 supports the <b>cmov</b> instruction, the <b>?:</b> construct can be compiled without using a jump.</p>
<pre class="syntax" xml:space="preserve"><code>                    dp.rgvarg = rgvarg;
                    dp.cArgs = 2;
                    dp.rgdispidNamedArgs = NULL;
                    dp.cNamedArgs = 0;

010011fd lea     rax,[rsp+0x80]             ; rax = &amp;rgvarg[0]
01001205 mov     [rsp+0x60],rax             ; dp.rgvarg = rgvarg
0100120a mov     [rsp+0x70],r15d            ; dp.cArgs = 2 (r15 is still 2)
0100120f mov     [rsp+0x68],r14             ; dp.rgdispidNamedArgs = NULL
01001214 mov     [rsp+0x74],r14d            ; dp.cNamedArgs = 0</code></pre>
<p>This code initializes the rest of the members of DISPPARAMS.  Note that the compiler reuses the space on the stack previously used by the CLSID.  </p>
<pre class="syntax" xml:space="preserve"><code>                    hr = pdisp-&gt;Invoke(dispid, IID_NULL, 0, DISPATCH_METHOD, &amp;dp, NULL, NULL, NULL);

01001219 mov     rax,[rsi]                  ; rax = pdisp.vtbl
0100121c mov     [rsp+0x40],r14             ; arg9 = 0
01001221 mov     [rsp+0x38],r14             ; arg8 = 0
01001226 mov     [rsp+0x30],r14             ; arg7 = 0
0100122b lea     rcx,[rsp+0x60]             ; rcx = &amp;dp
01001230 mov     [rsp+0x28],rcx             ; arg6 = &amp;dp
01001235 mov     word ptr [rsp+0x20],0x1    ; arg5 = 1 (DISPATCH_METHOD)
0100123c xor     r9d,r9d                    ; arg4 = 0
0100123f lea     r8,[GUID_NULL (01001080)]  ; arg3 = &amp;IID_NULL
01001246 mov     edx,r13d                   ; arg2 = dispid
01001249 mov     rcx,rsi                    ; arg1 = pdisp
0100124c call    qword ptr [rax+0x30]       ; call Invoke method
0100124f mov     ebx,eax                    ; hr = result</code></pre>
<p>The code then sets up the parameters and calls the <b>Invoke</b> method.</p>
<pre class="syntax" xml:space="preserve"><code>                    VariantClear(&amp;rgvarg[0]);
                    VariantClear(&amp;rgvarg[1]);

01001251 lea     rcx,[rsp+0x80]             ; arg1 = &amp;rgvarg[0]
01001259 call    qword ptr [_imp_VariantClear (01001018)]
0100125f lea     rcx,[rsp+0x98]             ; arg1 = &amp;rgvarg[1]
01001267 call    qword ptr [_imp_VariantClear (01001018)]
0100126d jmp     ReleasePQA (01001274)</code></pre>
<p>The code finishes up the current branch of the conditional, and skips over the <b>else</b> branch.</p>
<pre class="syntax" xml:space="preserve"><code>                } else {
                    hr = E_OUTOFMEMORY;
                }
            }

OutOfMemory:
0100126f mov     ebx,0x8007000e             ; hr = E_OUTOFMEMORY
        pqa-&gt;Release();
ReleasePQA:
01001274 mov     rcx,[rsp+0x58]             ; arg1 = pqa
01001279 mov     rax,[rcx]                  ; rax = pqa.vtbl
0100127c call    qword ptr [rax+0x10]       ; release</code></pre>
<p>The <b>else</b> branch.</p>
<pre class="syntax" xml:space="preserve"><code>    return hr;
}

0100127f mov     eax,ebx                    ; rax = hr (for return value)
ReturnEAX:
01001281 add     rsp,0x2c0                  ; clean up the stack
01001288 pop     r15d                       ; restore
0100128a pop     r14d                       ; restore
0100128c pop     r13d                       ; restore
0100128e pop     r12d                       ; restore
01001290 pop     rdi                        ; restore
01001291 pop     rsi                        ; restore
01001292 pop     rbx                        ; restore
01001293 ret                                ; return (do not pop arguments)</code></pre>
<p>The return value is stored in <b>rax</b>, and then the non-volatile registers are restored before returning.</p>
<p> </p>
<p> </p>
<p><a href="mailto:wsddocfb@microsoft.com?subject=Documentation%20feedback [debugger\debugger]:%20Annotated x64 Disassembly%20 RELEASE:%20(3/16/2017)&amp;body=%0A%0APRIVACY STATEMENT%0A%0AWe use your feedback to improve the documentation. We don't use your email address for any other purpose, and we'll remove your email address from our system after the issue that you're reporting is fixed. While we're working to fix this issue, we might send you an email message to ask for more info. Later, we might also send you an email message to let you know that we've addressed your feedback.%0A%0AFor more info about Microsoft's privacy policy, see http://privacy.microsoft.com/en-us/default.aspx." title="Send comments about this topic to Microsoft">Send comments about this topic to Microsoft</a></p>
</div>
<p style="text-align:left;font-family:Arial,sanserif;font-size:100%;color:black">
&#x00a9;&#x00a0;2016 Microsoft. All rights reserved.</p>

</body>
</html>
